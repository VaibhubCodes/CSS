This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-06-27T03:53:21.890Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
management/
  commands/
    __init__.py
    award_pending_coins.py
    check_expired_items.py
    check_pending_ocr.py
    diagnose_s3_files.py
    process_pending_files.py
    setup_file_categories.py
  __init__.py
migrations/
  0001_initial.py
  0002_ocrresult.py
  0003_ocrresult_job_id_alter_ocrresult_text_content.py
  0004_userfile_user_filecategory_userfile_category.py
  0005_carddetails_appsubscription.py
  0006_expirydetails.py
  0007_alter_userfile_options_userfile_file_size_and_more.py
  0008_alter_userfile_file_type_ocrpreference.py
  0009_userfile_is_favorite.py
  0010_userfile_coins_awarded.py
  0011_userfile_pending_auto_categorization_and_more.py
  0012_userfile_locked_userfile_locked_password.py
  0013_userfile_document_pairing.py
  0014_alter_userfile_document_side_and_more.py
  0015_alter_userfile_document_side_and_more.py
templates/
  file_management/
    cards/
      card_list.html
    subscriptions/
      subscription_list.html
    expired_items.html
    file_detail.html
    file_list.html
    upload.html
admin.py
apps.py
forms.py
models.py
serializers.py
services.py
signals.py
tasks.py
tests.py
urls.py
utils.py
views.py

================================================================
Repository Files
================================================================

================
File: management/commands/__init__.py
================
# This file is intentionally empty to mark the directory as a Python package

================
File: management/commands/award_pending_coins.py
================
from django.core.management.base import BaseCommand
import math
from file_management.models import UserFile
from coin_wallet.models import CoinWallet, CoinTransaction

class Command(BaseCommand):
    help = 'Award coins for files that have not been awarded coins yet'

    def handle(self, *args, **options):
        files_without_coins = UserFile.objects.filter(coins_awarded=False, file_size__gt=0)
        self.stdout.write(f"Found {files_without_coins.count()} files without coins awarded")
        
        for user_file in files_without_coins:
            try:
                # Calculate coins (1 coin per MB)
                file_size_mb = math.ceil(user_file.file_size / (1024 * 1024))
                if file_size_mb < 1:
                    file_size_mb = 1  # Minimum 1 coin per file
                
                # Get or create the user's wallet
                wallet, created = CoinWallet.objects.get_or_create(user=user_file.user)
                
                # Check if coins were already awarded for this file
                existing_transaction = CoinTransaction.objects.filter(
                    wallet=wallet,
                    transaction_type='upload',
                    related_file=user_file
                ).exists()
                
                if not existing_transaction:
                    # Award coins
                    wallet.add_coins(
                        amount=file_size_mb,
                        transaction_type='upload',
                        source=f'File upload: {user_file.original_filename}'
                    )
                    
                    # Update the transaction with the related file
                    transaction = CoinTransaction.objects.filter(
                        wallet=wallet,
                        transaction_type='upload'
                    ).latest('created_at')
                    transaction.related_file = user_file
                    transaction.save()
                    
                    # Mark coins as awarded
                    user_file.coins_awarded = True
                    user_file.save(update_fields=['coins_awarded'])
                    
                    self.stdout.write(
                        self.style.SUCCESS(
                            f"Awarded {file_size_mb} coins for file '{user_file.original_filename}' (ID: {user_file.id})"
                        )
                    )
                else:
                    # Already awarded but not marked
                    user_file.coins_awarded = True
                    user_file.save(update_fields=['coins_awarded'])
                    
                    self.stdout.write(
                        self.style.WARNING(
                            f"File '{user_file.original_filename}' already had coins awarded, marked as awarded"
                        )
                    )
                    
            except Exception as e:
                self.stdout.write(
                    self.style.ERROR(
                        f"Error awarding coins for file '{user_file.original_filename}' (ID: {user_file.id}): {str(e)}"
                    )
                )
        
        self.stdout.write(self.style.SUCCESS("Finished awarding coins for files"))

================
File: management/commands/check_expired_items.py
================
from django.core.management.base import BaseCommand
from file_management.services import ExpiryManagementService

class Command(BaseCommand):
    help = 'Check and move expired items to EXPIRED_DOCS category'

    def handle(self, *args, **options):
        service = ExpiryManagementService()
        service.check_and_move_expired_items()
        self.stdout.write(self.style.SUCCESS('Successfully checked for expired items'))

================
File: management/commands/check_pending_ocr.py
================
from django.core.management.base import BaseCommand
from file_management.services import OCRService

class Command(BaseCommand):
    help = 'Check and complete pending OCR jobs'

    def handle(self, *args, **options):
        ocr_service = OCRService()
        ocr_service.check_pending_jobs()
        self.stdout.write(self.style.SUCCESS('Successfully checked pending OCR jobs'))

================
File: management/commands/diagnose_s3_files.py
================
from django.core.management.base import BaseCommand
from file_management.models import UserFile
from storage_management.utils import S3StorageManager
import boto3
from django.conf import settings

class Command(BaseCommand):
    help = 'Diagnose S3 file storage issues'

    def add_arguments(self, parser):
        parser.add_argument('--file-id', type=int, help='Specific file ID to diagnose')
        parser.add_argument('--user-id', type=int, help='Specific user ID to check')
        parser.add_argument('--fix-keys', action='store_true', help='Attempt to fix incorrect S3 keys')

    def handle(self, *args, **options):
        if options['file_id']:
            self.diagnose_file(options['file_id'], options['fix_keys'])
        elif options['user_id']:
            self.diagnose_user_files(options['user_id'], options['fix_keys'])
        else:
            self.diagnose_all_files(options['fix_keys'])

    def diagnose_file(self, file_id, fix_keys=False):
        try:
            file = UserFile.objects.get(id=file_id)
            self.stdout.write(f"\n=== Diagnosing File {file_id} ===")
            self.stdout.write(f"Original filename: {file.original_filename}")
            self.stdout.write(f"File field: {file.file.name if file.file else 'None'}")
            self.stdout.write(f"S3 key: {file.s3_key}")
            
            storage_manager = S3StorageManager(file.user)
            
            # Check current S3 key
            if file.s3_key:
                exists = storage_manager.file_exists(file.s3_key)
                self.stdout.write(f"S3 key exists: {exists}")
            
            # Try to find the file with different keys
            possible_keys = [
                file.s3_key,
                file.file.name if file.file else None,
                f"uploads/{file.original_filename}",
                f"user_{file.user.id}/{file.original_filename}",
                file.original_filename
            ]
            
            working_key = None
            self.stdout.write(f"\nTrying different S3 keys:")
            for key in possible_keys:
                if key:
                    exists = storage_manager.file_exists(key)
                    self.stdout.write(f"  {key}: {'✓' if exists else '✗'}")
                    if exists and not working_key:
                        working_key = key
            
            if working_key and working_key != file.s3_key and fix_keys:
                self.stdout.write(f"\nFixing S3 key: {file.s3_key} → {working_key}")
                file.s3_key = working_key
                file.save(update_fields=['s3_key'])
                self.stdout.write("✓ S3 key updated")
            
        except UserFile.DoesNotExist:
            self.stdout.write(f"File {file_id} not found")
        except Exception as e:
            self.stdout.write(f"Error diagnosing file {file_id}: {str(e)}")

    def diagnose_user_files(self, user_id, fix_keys=False):
        files = UserFile.objects.filter(user_id=user_id)
        self.stdout.write(f"\n=== Diagnosing {files.count()} files for user {user_id} ===")
        
        for file in files:
            self.diagnose_file(file.id, fix_keys)

    def diagnose_all_files(self, fix_keys=False):
        files = UserFile.objects.all()
        self.stdout.write(f"\n=== Diagnosing {files.count()} total files ===")
        
        issues_found = 0
        for file in files:
            try:
                storage_manager = S3StorageManager(file.user)
                if file.s3_key and not storage_manager.file_exists(file.s3_key):
                    issues_found += 1
                    self.stdout.write(f"Issue: File {file.id} - S3 key not found: {file.s3_key}")
                    
                    if fix_keys:
                        self.diagnose_file(file.id, True)
                        
            except Exception as e:
                self.stdout.write(f"Error checking file {file.id}: {str(e)}")
        
        self.stdout.write(f"\nFound {issues_found} files with S3 issues")

================
File: management/commands/process_pending_files.py
================
from django.core.management.base import BaseCommand
from file_management.models import UserFile, FileCategory, OCRResult
from file_management.views import process_document_ocr_logic
import time

class Command(BaseCommand):
    help = 'Process files with pending auto-categorization'

    def handle(self, *args, **options):
        # Get all files with pending auto-categorization
        pending_files = UserFile.objects.filter(pending_auto_categorization=True)
        self.stdout.write(f"Found {pending_files.count()} files with pending auto-categorization")
        
        # Ensure Miscellaneous category exists
        misc_category, _ = FileCategory.objects.get_or_create(
            name='Miscellaneous',
            defaults={'is_default': True, 'description': 'Uncategorized files'}
        )
        
        for file in pending_files:
            self.stdout.write(f"Processing file {file.id}: {file.original_filename}")
            
            try:
                # Check if OCR already exists
                ocr_exists = OCRResult.objects.filter(file=file).exists()
                if ocr_exists:
                    self.stdout.write(f"  OCR result already exists for file {file.id}")
                
                # Process the file
                result = process_document_ocr_logic(file.user_id, file.id)
                self.stdout.write(f"  OCR result: {result}")
                
                # Sleep briefly to avoid overwhelming the system
                time.sleep(1)
                
                # Double-check the pending flag was cleared
                file.refresh_from_db()
                if file.pending_auto_categorization:
                    self.stdout.write(f"  Warning: Pending flag still set for file {file.id}, clearing manually")
                    file.pending_auto_categorization = False
                    file.save(update_fields=['pending_auto_categorization'])
                
            except Exception as e:
                self.stdout.write(self.style.ERROR(f"  Error processing file {file.id}: {str(e)}"))
                
                # Clear the pending flag anyway
                try:
                    file.pending_auto_categorization = False
                    if not file.category:
                        file.category = misc_category
                    file.save(update_fields=['pending_auto_categorization', 'category'])
                    self.stdout.write(f"  Cleared pending flag for file {file.id} after error")
                except Exception as inner_e:
                    self.stdout.write(self.style.ERROR(f"  Failed to clear pending flag: {str(inner_e)}"))
        
        # Check if any files still have pending flags
        still_pending = UserFile.objects.filter(pending_auto_categorization=True).count()
        if still_pending > 0:
            self.stdout.write(self.style.WARNING(f"{still_pending} files still have pending auto-categorization flags"))
        else:
            self.stdout.write(self.style.SUCCESS("All pending auto-categorization flags have been cleared"))

================
File: management/commands/setup_file_categories.py
================
from django.core.management.base import BaseCommand
from file_management.utils import create_default_categories

class Command(BaseCommand):
    help = 'Creates default file categories'

    def handle(self, *args, **options):
        create_default_categories()
        self.stdout.write(self.style.SUCCESS('Successfully created default categories'))

================
File: management/__init__.py
================
# This file is intentionally empty to mark the directory as a Python package

================
File: migrations/0001_initial.py
================
# Generated by Django 5.1.1 on 2024-11-08 12:01

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='UserFile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('file_type', models.CharField(choices=[('audio', 'Audio'), ('document', 'Document')], max_length=10)),
                ('file', models.FileField(upload_to='uploads/')),
                ('upload_date', models.DateTimeField(auto_now_add=True)),
            ],
        ),
    ]

================
File: migrations/0002_ocrresult.py
================
# Generated by Django 5.1.1 on 2024-11-26 19:14

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('file_management', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='OCRResult',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('text_content', models.TextField()),
                ('processed_date', models.DateTimeField(auto_now_add=True)),
                ('status', models.CharField(default='pending', max_length=20)),
                ('file', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='file_management.userfile')),
            ],
        ),
    ]

================
File: migrations/0003_ocrresult_job_id_alter_ocrresult_text_content.py
================
# Generated by Django 5.1.1 on 2024-11-26 20:05

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('file_management', '0002_ocrresult'),
    ]

    operations = [
        migrations.AddField(
            model_name='ocrresult',
            name='job_id',
            field=models.CharField(blank=True, max_length=100, null=True),
        ),
        migrations.AlterField(
            model_name='ocrresult',
            name='text_content',
            field=models.TextField(blank=True, null=True),
        ),
    ]

================
File: migrations/0004_userfile_user_filecategory_userfile_category.py
================
# Generated by Django 5.1.1 on 2024-11-27 08:23

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('file_management', '0003_ocrresult_job_id_alter_ocrresult_text_content'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddField(
            model_name='userfile',
            name='user',
            field=models.ForeignKey(default=1, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL),
            preserve_default=False,
        ),
        migrations.CreateModel(
            name='FileCategory',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=50)),
                ('description', models.TextField(blank=True, null=True)),
                ('is_default', models.BooleanField(default=False)),
                ('created_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name_plural': 'File Categories',
            },
        ),
        migrations.AddField(
            model_name='userfile',
            name='category',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to='file_management.filecategory'),
        ),
    ]

================
File: migrations/0005_carddetails_appsubscription.py
================
# Generated by Django 5.1.3 on 2024-12-23 09:33

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('file_management', '0004_userfile_user_filecategory_userfile_category'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CardDetails',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('card_type', models.CharField(choices=[('credit', 'Credit Card'), ('debit', 'Debit Card')], max_length=10)),
                ('bank_name', models.CharField(max_length=100)),
                ('card_number', models.CharField(max_length=16)),
                ('card_holder', models.CharField(max_length=100)),
                ('expiry_month', models.CharField(max_length=2)),
                ('expiry_year', models.CharField(max_length=4)),
                ('cvv', models.CharField(max_length=4)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('extracted_from_doc', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='file_management.userfile')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'ordering': ['-created_at'],
            },
        ),
        migrations.CreateModel(
            name='AppSubscription',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('app_name', models.CharField(max_length=100)),
                ('subscription_type', models.CharField(max_length=50)),
                ('amount', models.DecimalField(decimal_places=2, max_digits=10)),
                ('start_date', models.DateField()),
                ('end_date', models.DateField()),
                ('auto_renewal', models.BooleanField(default=True)),
                ('status', models.CharField(choices=[('active', 'Active'), ('expired', 'Expired'), ('canceled', 'Canceled')], default='active', max_length=20)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('extracted_from_doc', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='file_management.userfile')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
                ('payment_method', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='file_management.carddetails')),
            ],
            options={
                'ordering': ['-created_at'],
            },
        ),
    ]

================
File: migrations/0006_expirydetails.py
================
# Generated by Django 5.1.3 on 2024-12-26 21:44

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('file_management', '0005_carddetails_appsubscription'),
    ]

    operations = [
        migrations.CreateModel(
            name='ExpiryDetails',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('document_type', models.CharField(choices=[('document', 'Document'), ('card', 'Card'), ('subscription', 'Subscription')], max_length=20)),
                ('expiry_date', models.DateField()),
                ('moved_to_expired', models.BooleanField(default=False)),
                ('original_category', models.CharField(blank=True, max_length=100)),
                ('expired_s3_key', models.CharField(blank=True, max_length=255)),
                ('card', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='file_management.carddetails')),
                ('document', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='file_management.userfile')),
                ('subscription', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='file_management.appsubscription')),
            ],
        ),
    ]

================
File: migrations/0007_alter_userfile_options_userfile_file_size_and_more.py
================
# Generated by Django 5.1.3 on 2024-12-27 09:56

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('file_management', '0006_expirydetails'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='userfile',
            options={'ordering': ['-upload_date'], 'verbose_name': 'User File', 'verbose_name_plural': 'User Files'},
        ),
        migrations.AddField(
            model_name='userfile',
            name='file_size',
            field=models.BigIntegerField(default=0),
        ),
        migrations.AddField(
            model_name='userfile',
            name='is_public',
            field=models.BooleanField(default=False),
        ),
        migrations.AddField(
            model_name='userfile',
            name='original_filename',
            field=models.CharField(blank=True, max_length=255),
        ),
        migrations.AddField(
            model_name='userfile',
            name='s3_key',
            field=models.CharField(blank=True, max_length=255),
        ),
    ]

================
File: migrations/0008_alter_userfile_file_type_ocrpreference.py
================
# Generated by Django 5.1.3 on 2025-03-28 16:43

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("file_management", "0007_alter_userfile_options_userfile_file_size_and_more"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AlterField(
            model_name="userfile",
            name="file_type",
            field=models.CharField(
                choices=[
                    ("document", "Document"),
                    ("image", "Image"),
                    ("audio", "Audio"),
                ],
                max_length=10,
            ),
        ),
        migrations.CreateModel(
            name="OCRPreference",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "preference",
                    models.CharField(
                        choices=[
                            ("all", "Process OCR on all files"),
                            ("selected", "Process OCR only on selected files"),
                            ("none", "Do not process OCR on any files"),
                        ],
                        default="all",
                        max_length=10,
                    ),
                ),
                (
                    "user",
                    models.OneToOneField(
                        on_delete=django.db.models.deletion.CASCADE,
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
        ),
    ]

================
File: migrations/0009_userfile_is_favorite.py
================
# Generated by Django 5.1.1 on 2025-03-31 07:48

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('file_management', '0008_alter_userfile_file_type_ocrpreference'),
    ]

    operations = [
        migrations.AddField(
            model_name='userfile',
            name='is_favorite',
            field=models.BooleanField(default=False),
        ),
    ]

================
File: migrations/0010_userfile_coins_awarded.py
================
# Generated by Django 5.1.3 on 2025-04-21 18:36

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("file_management", "0009_userfile_is_favorite"),
    ]

    operations = [
        migrations.AddField(
            model_name="userfile",
            name="coins_awarded",
            field=models.BooleanField(default=False),
        ),
    ]

================
File: migrations/0011_userfile_pending_auto_categorization_and_more.py
================
# Generated by Django 5.1.3 on 2025-04-22 06:45

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("file_management", "0010_userfile_coins_awarded"),
    ]

    operations = [
        migrations.AddField(
            model_name="userfile",
            name="pending_auto_categorization",
            field=models.BooleanField(default=False),
        ),
        migrations.AlterField(
            model_name="userfile",
            name="category",
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                to="file_management.filecategory",
            ),
        ),
    ]

================
File: migrations/0012_userfile_locked_userfile_locked_password.py
================
# Generated by Django 5.1.3 on 2025-04-25 08:10

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("file_management", "0011_userfile_pending_auto_categorization_and_more"),
    ]

    operations = [
        migrations.AddField(
            model_name="userfile",
            name="locked",
            field=models.BooleanField(default=False),
        ),
        migrations.AddField(
            model_name="userfile",
            name="locked_password",
            field=models.CharField(blank=True, max_length=100, null=True),
        ),
    ]

================
File: migrations/0013_userfile_document_pairing.py
================
from django.db import migrations, models
import django.db.models.deletion

class Migration(migrations.Migration):
    dependencies = [
        ('file_management', '0012_userfile_locked_userfile_locked_password'),
    ]

    operations = [
        migrations.AddField(
            model_name='userfile',
            name='document_side',
            field=models.CharField(
                choices=[('single', 'Single Side'), ('front', 'Front Side'), ('back', 'Back Side')],
                default='single',
                max_length=10
            ),
        ),
        migrations.AddField(
            model_name='userfile',
            name='paired_document',
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                related_name='paired_with',
                to='file_management.userfile'
            ),
        ),
        migrations.AddField(
            model_name='userfile',
            name='document_type_name',
            field=models.CharField(
                blank=True,
                help_text='e.g., Aadhar Card, PAN Card, License',
                max_length=100
            ),
        ),
    ]

================
File: migrations/0014_alter_userfile_document_side_and_more.py
================
# Generated by Django 5.1.3 on 2025-05-24 19:37

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("file_management", "0013_userfile_document_pairing"),
    ]

    operations = [
        migrations.AlterField(
            model_name="userfile",
            name="document_side",
            field=models.CharField(
                choices=[
                    ("single", "Single Side"),
                    ("front", "Front Side"),
                    ("back", "Back Side"),
                ],
                default="single",
                help_text="Indicates if this document has a front/back side",
                max_length=10,
            ),
        ),
        migrations.AlterField(
            model_name="userfile",
            name="document_type_name",
            field=models.CharField(
                blank=True,
                help_text="Human readable document type (e.g., Aadhar Card, PAN Card)",
                max_length=100,
            ),
        ),
        migrations.AlterField(
            model_name="userfile",
            name="paired_document",
            field=models.ForeignKey(
                blank=True,
                help_text="Reference to the other side of this document",
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                related_name="paired_with",
                to="file_management.userfile",
            ),
        ),
    ]

================
File: migrations/0015_alter_userfile_document_side_and_more.py
================
# Generated by Django 5.1.3 on 2025-05-30 22:01

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("file_management", "0014_alter_userfile_document_side_and_more"),
    ]

    operations = [
        migrations.AlterField(
            model_name="userfile",
            name="document_side",
            field=models.CharField(
                choices=[
                    ("single", "Single Side"),
                    ("front", "Front Side"),
                    ("back", "Back Side"),
                ],
                default="single",
                max_length=10,
            ),
        ),
        migrations.AlterField(
            model_name="userfile",
            name="document_type_name",
            field=models.CharField(blank=True, max_length=100),
        ),
        migrations.AlterField(
            model_name="userfile",
            name="paired_document",
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                related_name="paired_with",
                to="file_management.userfile",
            ),
        ),
    ]

================
File: templates/file_management/cards/card_list.html
================
{# templates/file_management/cards/card_list.html #}
<!DOCTYPE html>
<html>
<head>
    <title>Card Management</title>
    <style>
        .cards-container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
        }

        .credit-card {
            width: 340px;
            height: 200px;
            margin: 20px;
            padding: 20px;
            border-radius: 15px;
            color: white;
            position: relative;
            display: inline-block;
            background: linear-gradient(45deg, #1a1a1a, #5c5c5c);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .card-chip {
            width: 50px;
            height: 40px;
            background: #ffd700;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .card-number {
            font-size: 1.5em;
            letter-spacing: 4px;
            margin-bottom: 20px;
        }

        .card-info {
            display: flex;
            justify-content: space-between;
        }

        .add-card-form {
            max-width: 500px;
            margin: 20px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
        }

        .form-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .btn {
            padding: 10px 20px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn:hover {
            background: #1d4ed8;
        }

        .error {
            color: red;
            margin-top: 5px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="cards-container">
        <h2>Your Cards</h2>

        <!-- Card List -->
        <div class="cards-list">
            {% for card in cards %}
            <div class="credit-card" data-card-id="{{ card.id }}">
                <div class="card-chip"></div>
                <div class="card-number">
                    **** **** **** {{ card.card_number|slice:"-4:" }}
                </div>
                <div class="card-info">
                    <div>
                        <div>{{ card.card_holder }}</div>
                        <div>{{ card.expiry_month }}/{{ card.expiry_year }}</div>
                    </div>
                    <div>
                        <div>{{ card.bank_name }}</div>
                        <div>{{ card.card_type }}</div>
                    </div>
                </div>
                <button onclick="deleteCard({{ card.id }})" class="btn btn-danger">Delete</button>
            </div>
            {% endfor %}
        </div>

        <!-- Add New Card Form -->
        <div class="add-card-form">
            <h3>Add New Card</h3>
            <form id="cardForm" onsubmit="addCard(event)">
                <div class="form-group">
                    <label>Card Type</label>
                    <select name="card_type" required>
                        <option value="credit">Credit Card</option>
                        <option value="debit">Debit Card</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Bank Name</label>
                    <input type="text" name="bank_name" required>
                </div>

                <div class="form-group">
                    <label>Card Number</label>
                    <input type="text" name="card_number" required pattern="\d{16}" 
                           title="Please enter 16 digits">
                </div>

                <div class="form-group">
                    <label>Card Holder Name</label>
                    <input type="text" name="card_holder" required>
                </div>

                <div class="form-group">
                    <label>Expiry Date</label>
                    <input type="text" name="expiry_month" placeholder="MM" required 
                           pattern="\d{2}" maxlength="2" style="width: 50px;">
                    <input type="text" name="expiry_year" placeholder="YYYY" required 
                           pattern="\d{4}" maxlength="4" style="width: 70px;">
                </div>

                <div class="form-group">
                    <label>CVV</label>
                    <input type="password" name="cvv" required pattern="\d{3,4}" 
                           maxlength="4">
                </div>

                <button type="submit" class="btn">Add Card</button>
            </form>
        </div>

        <!-- Extract from Document Form -->
        <div class="add-card-form">
            <h3>Extract Card from Document</h3>
            <form id="extractForm" onsubmit="extractFromDocument(event)">
                <div class="form-group">
                    <label>Select Document</label>
                    <select name="file_id" required>
                        {% for file in files %}
                            <option value="{{ file.id }}">{{ file.file.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <button type="submit" class="btn">Extract Card Details</button>
            </form>
        </div>
    </div>

    
<script>

    async function addCard(event) {
        event.preventDefault();
        const form = event.target;
        const formData = new FormData(form);

        try {
            const response = await fetch('/file_management/api/cards/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify(Object.fromEntries(formData))
            });

            if (response.ok) {
                window.location.reload();
            } else {
                const error = await response.json();
                alert(JSON.stringify(error));
            }
        } catch (error) {
            console.error('Error:', error);
            alert('Error adding card');
        }
    }

    async function deleteCard(cardId) {
        if (!confirm('Are you sure you want to delete this card?')) return;

        try {
            const response = await fetch(`/file_management/api/cards/${cardId}/`, {
                method: 'DELETE',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                }
            });

            if (response.ok) {
                window.location.reload();
            } else {
                alert('Error deleting card');
            }
        } catch (error) {
            console.error('Error:', error);
            alert('Error deleting card');
        }
    }

    async function extractFromDocument(event) {
        event.preventDefault();
        const form = event.target;
        const formData = new FormData(form);

        try {
            const response = await fetch('/file_management/api/cards/extract_from_document/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    file_id: formData.get('file_id')
                })
            });

            const data = await response.json();
            if (response.ok) {
                if (data.cards_found.length > 0) {
                    const confirmed = confirm(
                        `Found ${data.cards_found.length} card(s). Would you like to add them?`
                    );
                    if (confirmed) {
                        // Add each found card
                        for (const card of data.cards_found) {
                            await fetch('/file_management/api/cards/', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': getCookie('csrftoken')
                                },
                                body: JSON.stringify(card)
                            });
                        }
                        window.location.reload();
                    }
                } else {
                    alert('No cards found in the document');
                }
            } else {
                alert(data.error || 'Error extracting card details');
            }
        } catch (error) {
            console.error('Error:', error);
            alert('Error extracting card details');
        }
    }
    function getCookie(name) {
                let cookieValue = null;
                if (document.cookie && document.cookie !== '') {
                    const cookies = document.cookie.split(';');
                    for (let i = 0; i < cookies.length; i++) {
                        const cookie = cookies[i].trim();
                        if (cookie.substring(0, name.length + 1) === (name + '=')) {
                            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                            break;
                        }
                    }
                }
                return cookieValue;
            }

</script>
</body>
</html>

================
File: templates/file_management/subscriptions/subscription_list.html
================
{# templates/file_management/subscriptions/subscription_list.html #}
<!DOCTYPE html>
<html>
<head>
    <title>Subscription Management</title>
    <style>
        .subscriptions-container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
        }

        .subscription-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 10px 0;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .subscription-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .subscription-title {
            font-size: 1.2em;
            font-weight: bold;
        }

        .subscription-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .status-active {
            background: #dcfce7;
            color: #166534;
        }

        .status-expired {
            background: #fee2e2;
            color: #991b1b;
        }

        .subscription-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .subscription-form {
            max-width: 500px;
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .btn {
            padding: 10px 20px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn:hover {
            background: #1d4ed8;
        }
    </style>
</head>
<body>
    <div class="subscriptions-container">
        <h2>Your Subscriptions</h2>

        <!-- Subscription List -->
        <div class="subscriptions-list">
            {% for sub in subscriptions %}
            <div class="subscription-card">
                <div class="subscription-header">
                    <div class="subscription-title">{{ sub.app_name }}</div>
                    <div class="subscription-status status-{{ sub.status }}">
                        {{ sub.status|title }}
                    </div>
                </div>
                <div class="subscription-details">
                    <div>
                        <strong>Type:</strong> {{ sub.subscription_type }}
                    </div>
                    <div>
                        <strong>Amount:</strong> ₹{{ sub.amount }}
                    </div>
                    <div>
                        <strong>Start Date:</strong> {{ sub.start_date }}
                    </div>
                    <div>
                        <strong>End Date:</strong> {{ sub.end_date }}
                    </div>
                    <div>
                        <strong>Auto Renewal:</strong> {{ sub.auto_renewal|yesno }}
                    </div>
                    {% if sub.payment_method %}
                    <div>
                        <strong>Payment Method:</strong> 
                        {{ sub.payment_method.bank_name }} (**** {{ sub.payment_method.card_number|slice:"-4:" }})
                    </div>
                    {% endif %}
                </div>
                <button onclick="deleteSubscription({{ sub.id }})" class="btn btn-danger">
                    Delete
                </button>
            </div>
            {% endfor %}
        </div>

        <!-- Add New Subscription Form -->
        <div class="subscription-form">
            <h3>Add New Subscription</h3>
            <form id="subscriptionForm" onsubmit="addSubscription(event)">
                <div class="form-group">
                    <label>App/Service Name</label>
                    <input type="text" name="app_name" required>
                </div>

                <div class="form-group">
                    <label>Subscription Type</label>
                    <select name="subscription_type" required>
                        <option value="Monthly">Monthly</option>
                        <option value="Annual">Annual</option>
                        <option value="Quarterly">Quarterly</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Amount</label>
                    <input type="number" name="amount" step="0.01" required>
                </div>

                <div class="form-group">
                    <label>Start Date</label>
                    <input type="date" name="start_date" required>
                </div>

                <div class="form-group">
                    <label>End Date</label>
                    <input type="date" name="end_date" required>
                </div>

                <div class="form-group">
                    <label>Payment Method</label>
                    <select name="payment_method_id">
                        <option value="">Select Payment Method</option>
                        {% for card in cards %}
                        <option value="{{ card.id }}">
                            {{ card.bank_name }} - **** {{ card.card_number|slice:"-4:" }}
                        </option>
                        {% endfor %}
                    </select>
                </div>

                <div class="form-group">
                    <label>
                        <input type="checkbox" name="auto_renewal">
                        Auto Renewal
                    </label>
                </div>

                <button type="submit" class="btn">Add Subscription</button>
            </form>
        </div>

        <!-- Extract from Document Form -->
        <div class="subscription-form">
            <h3>Extract Subscription from Document</h3>
            <form id="extractForm" onsubmit="extractFromDocument(event)">
                <div class="form-group">
                    <label>Select Document</label>
                    <select name="file_id" required>
                        {% for file in files %}
                            <option value="{{ file.id }}">{{ file.file.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <button type="submit" class="btn">Extract Subscription Details</button>
            </form>
        </div>
    </div>

    <script>
        async function addSubscription(event) {
            event.preventDefault();
            const form = event.target;
            const formData = new FormData(form);
            
            const data = {
                app_name: formData.get('app_name'),
                subscription_type: formData.get('subscription_type'),
                amount: parseFloat(formData.get('amount')),
                start_date: formData.get('start_date'),
                end_date: formData.get('end_date'),
                auto_renewal: formData.get('auto_renewal') === 'on',
                status: 'active'
            };
    
            if (formData.get('payment_method_id')) {
                data.payment_method_id = parseInt(formData.get('payment_method_id'));
            }
    
            try {
                const response = await fetch('/file_management/api/subscriptions/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify(data)
                });
    
                if (response.ok) {
                    window.location.reload();
                } else {
                    const errorData = await response.json();
                    let errorMessage = 'Error adding subscription:\n';
                    if (typeof errorData === 'object') {
                        Object.entries(errorData).forEach(([key, value]) => {
                            errorMessage += `\n${key}: ${value}`;
                        });
                    } else {
                        errorMessage = errorData.toString();
                    }
                    alert(errorMessage);
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error adding subscription: ' + error.message);
            }
        }
    
        async function extractFromDocument(event) {
            event.preventDefault();
            const form = event.target;
            const formData = new FormData(form);
    
            try {
                const response = await fetch('/file_management/api/subscriptions/extract_from_document/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        file_id: formData.get('file_id')
                    })
                });
    
                const data = await response.json();
                if (response.ok) {
                    if (data.subscriptions_found.length > 0) {
                        const confirmed = confirm(
                            `Found ${data.subscriptions_found.length} subscription(s). Would you like to add them?`
                        );
                        if (confirmed) {
                            for (const sub of data.subscriptions_found) {
                                await fetch('/file_management/api/subscriptions/', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': getCookie('csrftoken')
                                    },
                                    body: JSON.stringify(sub)
                                });
                            }
                            window.location.reload();
                        }
                    } else {
                        alert('No subscriptions found in the document');
                    }
                } else {
                    alert(data.error || 'Error extracting subscription details');
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error extracting subscription details');
            }
        }
        
        function getCookie(name) {
                let cookieValue = null;
                if (document.cookie && document.cookie !== '') {
                    const cookies = document.cookie.split(';');
                    for (let i = 0; i < cookies.length; i++) {
                        const cookie = cookies[i].trim();
                        if (cookie.substring(0, name.length + 1) === (name + '=')) {
                            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                            break;
                        }
                    }
                }
                return cookieValue;
            }
    
        async function deleteSubscription(subId) {
        if (!confirm('Are you sure you want to delete this subscription?')) return;

        try {
            const response = await fetch(`/file_management/api/subscriptions/${subId}/`, {
                method: 'DELETE',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                }
            });

            if (response.ok) {
                window.location.reload();
            } else {
                alert('Error deleting subscription');
            }
        } catch (error) {
            console.error('Error:', error);
            alert('Error deleting subscription');
        }
    }    
    </script>

</body>
</html>

================
File: templates/file_management/expired_items.html
================
{# templates/file_management/expired_items.html #}
<div class="expired-items-container">
    <h2>Expired Items</h2>
    
    {% for item in expired_items %}
        <div class="expired-item">
            {% if item.document %}
                <div class="document-item">
                    <h3>Document</h3>
                    <p>Name: {{ item.document.file.name }}</p>
                    <p>Original Category: {{ item.original_category }}</p>
                    <p>Expired On: {{ item.expiry_date }}</p>
                </div>
            {% elif item.card %}
                <div class="card-item">
                    <h3>Card</h3>
                    <p>Bank: {{ item.card.bank_name }}</p>
                    <p>Card Number: **** {{ item.card.card_number|slice:"-4:" }}</p>
                    <p>Expired On: {{ item.expiry_date }}</p>
                </div>
            {% else %}
                <div class="subscription-item">
                    <h3>Subscription</h3>
                    <p>Service: {{ item.subscription.app_name }}</p>
                    <p>Plan: {{ item.subscription.subscription_type }}</p>
                    <p>Expired On: {{ item.expiry_date }}</p>
                </div>
            {% endif %}
        </div>
    {% endfor %}
</div>

<style>
.expired-items-container {
    padding: 20px;
}

.expired-item {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    border-left: 4px solid #dc3545;
}

.expired-item h3 {
    color: #dc3545;
    margin-top: 0;
}
</style>

================
File: templates/file_management/file_detail.html
================
{% block content %}
<div class="file-detail">
    <h2>File Details</h2>
    <div class="file-info">
        <p>File Name: {{ file.file.name }}</p>
        <p>File Type: {{ file.file_type }}</p>
        <p>Upload Date: {{ file.upload_date }}</p>
    </div>
    
    {% if file.file_type == 'document' %}
    <button onclick="startOCR({{ file.id }})" class="btn btn-primary">
        Process with OCR
    </button>
    
    <div id="ocrResult" style="display: none;">
        <h3>OCR Result</h3>
        <div id="ocrContent"></div>
    </div>
    {% endif %}
</div>

<script>
async function startOCR(fileId) {
    try {
        const response = await fetch(`/file_management/ocr/process/${fileId}/`);
        const data = await response.json();
        
        if (data.job_id) {
            checkOCRStatus(data.job_id);
        }
    } catch (error) {
        console.error('Error starting OCR:', error);
    }
}

async function checkOCRStatus(jobId) {
    try {
        const response = await fetch(`/file_management/ocr/result/${jobId}/`);
        const data = await response.json();
        
        if (data.status === 'completed') {
            displayOCRResult(data.text);
        } else if (data.status === 'failed') {
            alert('OCR processing failed');
        } else {
            // Check again after 2 seconds
            setTimeout(() => checkOCRStatus(jobId), 2000);
        }
    } catch (error) {
        console.error('Error checking OCR status:', error);
    }
}

function displayOCRResult(text) {
    const resultDiv = document.getElementById('ocrResult');
    const contentDiv = document.getElementById('ocrContent');
    resultDiv.style.display = 'block';
    contentDiv.innerHTML = text.join('<br>');
}
</script>
{% endblock %}

================
File: templates/file_management/file_list.html
================
{# file_management/templates/file_management/file_list.html #}
<h2>Uploaded Files</h2>


<div class="content-container">
    <!-- Categories Section -->
    <div class="categories-section">
        <h3>Files & Quick Access</h3>
        <div class="category-pills">
            <div class="category-pill active" onclick="filterItems('all', this)">All</div>
            
            <!-- Regular Categories -->
            {% for category in categories %}
                {% if category.type == 'regular' %}
                    <div class="category-pill" 
                        data-category="{{ category.name }}"
                        data-count="{{ category.count }}"
                        onclick="filterItems('{{ category.name }}', this)">
                        {{ category.name }} ({{ category.count }})
                    </div>
                {% endif %}
            {% endfor %}
            
            <!-- Special Categories -->
            {% for category in categories %}
                {% if category.type == 'special' %}
                    <div class="category-pill special" 
                        data-category="{{ category.name }}"
                        data-count="{{ category.count }}"
                        onclick="showPreview('{{ category.name|lower }}')">
                        {{ category.name }} 
                        <span class="count-detail">
                            (Active: {{ category.count }}/Total: {{ category.total_count }})
                        </span>
                    </div>
                {% endif %}
            {% endfor %}
            
            <!-- Expired Category -->
            {% for category in categories %}
                {% if category.type == 'expired' %}
                    <div class="category-pill expired" 
                        data-category="{{ category.name }}"
                        data-count="{{ category.count }}"
                        onclick="showPreview('expired')">
                        {{ category.name }} ({{ category.count }})
                    </div>
                {% endif %}
            {% endfor %}
        </div>
    </div>

    <!-- Main Content -->
    <div class="files-container">
        <!-- Files List -->
        <div id="files-list">
            <table border="1">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Type</th>
                        <th>Name</th>
                        <th>Category</th>
                        <th>Upload Date</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% for file in files %}
                    <tr class="file-row" data-category="{{ file.category.name|default:'Uncategorized' }}" data-file-id="{{ file.id }}">
                        <td>{{ file.id }}</td>
                        <td>{{ file.file_type }}</td>
                        <td><a href="{{ file.get_file_url }}">{{ file.file.name }}</a></td>
                        <td><span class="category-tag">{{ file.category.name|default:'Uncategorized' }}</span></td>
                        <td>{{ file.upload_date }}</td>
                        <td>
                            <div class="action-buttons">
                                {% if file.file_type == 'document' %}
                                <button onclick="startOCR({{ file.id }})" class="action-btn">Process OCR</button>
                                <span id="processing-status-{{ file.id }}"></span>
                                {% endif %}
                                <button onclick="deleteFile({{ file.id }})" class="delete-btn">Delete</button>
                            </div>
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>

        <!-- Cards Preview -->
    <div id="cards-preview" class="preview-section" style="display: none;">
        <div class="preview-header">
            <h3>Cards Quick View</h3>
            <button onclick="window.location.href='/file_management/cards/'" class="view-all-btn">View All Cards</button>
        </div>
        <div class="preview-grid">
            {% for card in active_cards %}
            <div class="preview-card" onclick="window.location.href='/file_management/cards/'">
                <div class="card-type">{{ card.card_type|title }} Card</div>
                <div class="card-number">**** {{ card.card_number|slice:"-4:" }}</div>
                <div class="card-info">
                    <div class="card-holder">{{ card.card_holder }}</div>
                    <div class="bank-name">{{ card.bank_name }}</div>
                </div>
                <span class="status-active">Active</span>
            </div>
            {% endfor %}
        </div>
    </div>

        <!-- Subscriptions Preview -->
    <div id="subscriptions-preview" class="preview-section" style="display: none;">
        <div class="preview-header">
            <h3>Subscriptions Quick View</h3>
            <button onclick="window.location.href='/file_management/subscriptions/'" class="view-all-btn">View All Subscriptions</button>
        </div>
        <div class="preview-grid">
            {% for sub in active_subscriptions %}
            <div class="preview-card" onclick="window.location.href='/file_management/subscriptions/'">
                <div class="sub-name">{{ sub.app_name }}</div>
                <div class="sub-info">
                    <span class="sub-amount">₹{{ sub.amount }}</span>
                    <span class="sub-status status-{{ sub.current_status }}">{{ sub.current_status }}</span>
                </div>
                <div class="sub-type">{{ sub.subscription_type }}</div>
            </div>
            {% endfor %}
        </div>
    </div>

    <!-- Expired Items Preview -->
    <div id="expired-preview" class="preview-section" style="display: none;">
        <div class="preview-header">
            <h3>Expired Items</h3>
        </div>
        <div class="preview-grid">
            {% if expired_items.documents %}
            <div class="expired-section">
                <h4>Documents</h4>
                {% for doc in expired_items.documents %}
                <div class="preview-card">
                    <div class="doc-name">{{ doc.file.name }}</div>
                    <div class="doc-type">{{ doc.file_type }}</div>
                    <span class="status-expired">Expired</span>
                </div>
                {% endfor %}
            </div>
            {% endif %}

            {% if expired_items.cards %}
            <div class="expired-section">
                <h4>Cards</h4>
                {% for card in expired_items.cards %}
                <div class="preview-card">
                    <div class="card-type">{{ card.card_type|title }} Card</div>
                    <div class="card-number">**** {{ card.card_number|slice:"-4:" }}</div>
                    <span class="status-expired">Expired</span>
                </div>
                {% endfor %}
            </div>
            {% endif %}

            {% if expired_items.subscriptions %}
            <div class="expired-section">
                <h4>Subscriptions</h4>
                {% for sub in expired_items.subscriptions %}
                <div class="preview-card">
                    <div class="sub-name">{{ sub.app_name }}</div>
                    <div class="sub-type">{{ sub.subscription_type }}</div>
                    <span class="status-expired">Expired</span>
                </div>
                {% endfor %}
            </div>
            {% endif %}
        </div>
    </div>

        <!-- OCR Results Container -->
        <div id="ocr-container">
            <div id="ocrResult" class="ocr-result-panel">
                <div class="ocr-header">
                    <h3>OCR Result</h3>
                    <button onclick="closeOCR()" class="close-btn">×</button>
                </div>
                <div id="ocrContent" class="ocr-content"></div>
            </div>
        </div>
    </div>
</div>

<style>
    .categories-section {
    margin: 20px 0;
    padding: 15px;
    background: #f8fafc;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    overflow-x: auto; /* Add horizontal scroll for small screens */
}
    
    .category-pills {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 4px;
        min-width: min-content; /* Ensure pills don't shrink too much */
    }
    
    .category-pill {
    padding: 6px 12px;
    background: #e2e8f0;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap; /* Prevent text wrapping */
    font-size: 13px;
    line-height: 1.2;
    min-width: fit-content;
}
    
    .category-pill:hover {
        background: #cbd5e1;
    }
    
    .category-pill.active {
        background: #2563eb;
        color: white;
    }
    
    .preview-section {
    margin-top: 20px;
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
    
    .preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }
    
    .preview-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 16px;
    margin-top: 16px;
}
    
    .preview-card {
        background: #f8fafc;
        padding: 16px;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.2s;
    }
    
    .preview-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    .status-active {
        background: #dcfce7;
        color: #166534;
        padding: 4px 8px;
        border-radius: 4px;
    }
    
    .status-expired {
        background: #fee2e2;
        color: #991b1b;
        padding: 4px 8px;
        border-radius: 4px;
    }
    
    .view-all-btn {
        background: #2563eb;
        color: white;
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
    }
    
    .view-all-btn:hover {
        background: #1d4ed8;
    }

    .action-buttons {
    display: flex;
    gap: 8px;
    align-items: center;
    }   

    .action-btn {
        padding: 6px 12px;
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }

    .delete-btn {
        padding: 6px 12px;
        background: #dc2626;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }

    .delete-btn:hover {
        background: #b91c1c;
    }

    .action-btn:hover {
        background: #1d4ed8;
    }
    
    .content-container {
    padding: 20px;
}

    .files-container {
        position: relative;
    }

    .ocr-result-panel {
        display: none;
        margin-top: 20px;
        padding: 20px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .ocr-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }

    .close-btn {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #666;
    }

    .close-btn:hover {
        color: #000;
    }

    .ocr-content {
        max-height: 400px;
        overflow-y: auto;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 4px;
    }

    .action-buttons {
        display: flex;
        gap: 8px;
        align-items: center;
    }

    .expired-section {
        margin-bottom: 24px;
    }

    .expired-section h4 {
        margin: 0 0 12px 0;
        color: #dc2626;
        font-size: 16px;
    }

    @media (max-width: 640px) {
        .category-pills {
            flex-wrap: nowrap;
            overflow-x: auto;
            padding-bottom: 8px;
            -webkit-overflow-scrolling: touch;
        }
        
        .preview-grid {
            grid-template-columns: 1fr;
        }
    }

    .category-pill.special {
        background: #818cf8;
        color: white;
    }

    .category-pill.expired {
        background: #ef4444;
        color: white;
    }

    .count-detail {
        font-size: 12px;
        opacity: 0.9;
    }


    .categories-section h3 {
        margin: 0;
        color: #1f2937;
        font-size: 16px;
        font-weight: 600;
    }


</style>

<script>
    function showPreview(type) {
    // Hide all containers first
    document.getElementById('files-list').style.display = 'none';
    document.getElementById('cards-preview').style.display = 'none';
    document.getElementById('subscriptions-preview').style.display = 'none';
    document.getElementById('expired-preview').style.display = 'none';

    // Show the selected container
    switch(type) {
        case 'cards':
            document.getElementById('cards-preview').style.display = 'block';
            break;
        case 'subscriptions':
            document.getElementById('subscriptions-preview').style.display = 'block';
            break;
        case 'expired':
            document.getElementById('expired-preview').style.display = 'block';
            break;
        default:
            document.getElementById('files-list').style.display = 'block';
    }

    // Update active pill
    updateActivePill(type);
}

async function startOCR(fileId) {
    const processingStatus = document.getElementById(`processing-status-${fileId}`);
    if (processingStatus) {
        processingStatus.textContent = 'Processing...';
    }
    
    try {
        const response = await fetch(`/file_management/ocr/process/${fileId}/`);
        const data = await response.json();
        
        if (data.status === 'completed') {
            displayOCRResult(data.text);
            if (processingStatus) {
                processingStatus.textContent = 'Completed';
            }
            updateCategory(fileId, data.category || 'Personal');
        } else if (data.job_id) {
            if (processingStatus) {
                processingStatus.textContent = 'Processing (0%)...';
            }
            checkOCRStatus(data.job_id, fileId, 0);
        } else {
            if (processingStatus) {
                processingStatus.textContent = 'Failed: ' + (data.error || 'Unknown error');
            }
            console.error('OCR Error:', data);
            updateCategory(fileId, 'Personal');
        }
    } catch (error) {
        console.error('Error starting OCR:', error);
        if (processingStatus) {
            processingStatus.textContent = 'Failed to start OCR: ' + error.message;
        }
        updateCategory(fileId, 'Personal');
    }
}

async function checkOCRStatus(jobId, fileId, attempts) {
    const processingStatus = document.getElementById(`processing-status-${fileId}`);
    const maxAttempts = 120; // 10 minutes (120 * 5 seconds)
    
    try {
        const response = await fetch(`/file_management/ocr/result/${jobId}/`);
        const data = await response.json();
        
        if (data.status === 'completed') {
            displayOCRResult(data.text);
            processingStatus.textContent = 'Completed';
            updateCategory(fileId, data.category || 'Personal');
        } else if (data.status === 'failed') {
            processingStatus.textContent = 'Failed: ' + (data.error || 'Unknown error');
            console.error('OCR Status Error:', data);  // Add logging
            updateCategory(fileId, 'Personal');
        } else if (attempts >= maxAttempts) {
            processingStatus.textContent = 'Timeout: Processing took too long';
            updateCategory(fileId, 'Personal');
        } else {
            const progress = Math.min(95, Math.round((attempts / maxAttempts) * 100));
            processingStatus.textContent = `Processing (${progress}%)...`;
            setTimeout(() => checkOCRStatus(jobId, fileId, attempts + 1), 5000);
        }
    } catch (error) {
        console.error('Error checking OCR status:', error);
        if (attempts < maxAttempts) {
            setTimeout(() => checkOCRStatus(jobId, fileId, attempts + 1), 5000);
            processingStatus.textContent = `Error checking status. Retrying... (${attempts}/${maxAttempts})`;
        } else {
            processingStatus.textContent = 'Failed: Too many errors';
            updateCategory(fileId, 'Personal');
        }
    }
}

function displayOCRResult(text) {
    const resultDiv = document.getElementById('ocrResult');
    const contentDiv = document.getElementById('ocrContent');
    
    if (!resultDiv || !contentDiv) {
        console.error('OCR result elements not found');
        return;
    }
    
    resultDiv.style.display = 'block';
    
    if (Array.isArray(text)) {
        contentDiv.innerHTML = text.join('<br>');
    } else if (typeof text === 'string') {
        contentDiv.innerHTML = text;
    } else {
        contentDiv.innerHTML = JSON.stringify(text, null, 2);
    }
    
    resultDiv.scrollIntoView({ behavior: 'smooth' });
}

    function updateCategory(fileId, category) {
    const row = document.querySelector(`tr[data-file-id="${fileId}"]`);
    if (row) {
        const categoryTag = row.querySelector('.category-tag');
        if (categoryTag) {
            categoryTag.textContent = category;
        }
        row.setAttribute('data-category', category);
    }
}

    function filterFiles(category) {
        const rows = document.querySelectorAll('tr.file-row');
        const pills = document.querySelectorAll('.category-pill');
        
        // Update active pill
        pills.forEach(pill => {
            pill.classList.remove('active');
            if (pill.textContent.trim() === category || (category === 'all' && pill.textContent.trim() === 'All')) {
                pill.classList.add('active');
            }
        });
        
        // Filter rows
        rows.forEach(row => {
            const rowCategory = row.getAttribute('data-category');
            if (category === 'all' || rowCategory === category) {
                row.style.display = '';
            } else {
                row.style.display = 'none';
            }
        });
    }

    function handleSpecialCategory(category) {
    // Hide all containers
    document.getElementById('files-list').style.display = 'none';
    document.getElementById('cards-preview').style.display = 'none';
    document.getElementById('subscriptions-preview').style.display = 'none';

    // Show selected category
    if (category === 'cards') {
        document.getElementById('cards-preview').style.display = 'block';
    } else if (category === 'subscriptions') {
        document.getElementById('subscriptions-preview').style.display = 'block';
    }

    // Update active pill
    updateActivePill(category);
}

    function filterItems(category, pill) {
        // Show files list and hide all previews
        document.getElementById('files-list').style.display = 'block';
        document.getElementById('cards-preview').style.display = 'none';
        document.getElementById('subscriptions-preview').style.display = 'none';
        document.getElementById('expired-preview').style.display = 'none';
        
        // Filter files
        document.querySelectorAll('tr.file-row').forEach(row => {
            row.style.display = (category === 'all' || row.dataset.category === category) ? '' : 'none';
        });

        // Update active pill
        document.querySelectorAll('.category-pill').forEach(p => p.classList.remove('active'));
        if (pill) pill.classList.add('active');
    }

    function updateActivePill(category) {
        const pills = document.querySelectorAll('.category-pill');
        pills.forEach(pill => {
            pill.classList.remove('active');
            if (pill.textContent.toLowerCase().includes(category.toLowerCase())) {
                pill.classList.add('active');
            }
        });
    }

    async function deleteFile(fileId) {
    if (!confirm('Are you sure you want to delete this file? This action cannot be undone.')) {
        return;
    }

    try {
        // Get the row and category before making the delete request
        const row = document.querySelector(`tr[data-file-id="${fileId}"]`);
        const category = row ? row.getAttribute('data-category') : null;

        const response = await fetch(`/file_management/delete/${fileId}/`, {
            method: 'POST',  // Changed to POST for better security
            headers: {
                'X-CSRFToken': getCookie('csrftoken'),
                'Content-Type': 'application/json'
            }
        });

        const data = await response.json();

        if (response.ok) {
            // Remove the row if it exists
            if (row) {
                // Update category count if we have the category
                if (category) {
                    const categoryPill = document.querySelector(`.category-pill[data-category="${category}"]`);
                    if (categoryPill) {
                        const currentCount = parseInt(categoryPill.getAttribute('data-count') || '0');
                        const newCount = Math.max(0, currentCount - 1);
                        categoryPill.setAttribute('data-count', newCount);
                        categoryPill.textContent = `${category} (${newCount})`;
                    }
                }
                row.remove();
            }
            
            alert('File deleted successfully');
            // Optionally reload the page to refresh all counts
            window.location.reload();
        } else {
            throw new Error(data.message || 'Error deleting file');
        }
    } catch (error) {
        console.error('Error:', error);
        alert('Error deleting file: ' + error.message);
    }
}

    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    function closeOCR() {
    const resultDiv = document.getElementById('ocrResult');
    if (resultDiv) {
        resultDiv.style.display = 'none';
    }
}

</script>

================
File: templates/file_management/upload.html
================
<h2>Upload a File</h2>
<form method="post" enctype="multipart/form-data">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Upload</button>
</form>

================
File: admin.py
================
from django.contrib import admin
from .models import UserFile, FileCategory, OCRResult, OCRPreference, CardDetails, AppSubscription, ExpiryDetails
from storage_management.utils import S3StorageManager
from django.db import transaction
from .views import process_document_ocr_logic
from .services import OCRService
from django.contrib import messages

@admin.register(UserFile)
class UserFileAdmin(admin.ModelAdmin):
    list_display = ('original_filename', 'user', 'file_type', 'category', 'upload_date', 'get_file_size_display', 'is_public', 'pending_auto_categorization')
    list_filter = ('file_type', 'category', 'is_public', 'upload_date', 'pending_auto_categorization')
    search_fields = ('original_filename', 'user__email')
    readonly_fields = ('s3_key', 'file_size', 'upload_date')
    
    # def get_s3_status(self, obj):
    #     """Check if file exists in S3"""
    #     try:
    #         if not obj.s3_key:
    #             return "❌ No S3 Key"
            
    #         storage_manager = S3StorageManager(obj.user)
            
    #         # Check multiple possible keys
    #         possible_keys = [
    #             obj.s3_key,
    #             obj.file.name if obj.file else None,
    #             f"uploads/{obj.original_filename}" if obj.original_filename else None,
    #             f"user_{obj.user.id}/{obj.original_filename}" if obj.original_filename else None,
    #         ]
            
    #         for key in possible_keys:
    #             if key and storage_manager.file_exists(key):
    #                 return f"✅ Found: {key}"
            
    #         return "❌ Not Found in S3"
            
    #     except Exception as e:
    #         return f"❌ Error: {str(e)}"
    
    # get_s3_status.short_description = 'S3 Status'
    
    # def get_s3_debug_info(self, obj):
    #     """Get detailed S3 debug information"""
    #     try:
    #         info = []
    #         info.append(f"S3 Key: {obj.s3_key}")
    #         info.append(f"File Name: {obj.file.name if obj.file else 'None'}")
    #         info.append(f"Original Filename: {obj.original_filename}")
            
    #         if obj.s3_key or obj.file:
    #             storage_manager = S3StorageManager(obj.user)
                
    #             # List all files for this user
    #             user_files = storage_manager.list_user_files_with_details()
    #             info.append(f"\nAll S3 files for user:")
    #             for file_info in user_files[:10]:  # Show first 10
    #                 info.append(f"  - {file_info['key']} ({file_info['size']} bytes)")
                
    #             if len(user_files) > 10:
    #                 info.append(f"  ... and {len(user_files) - 10} more files")
            
    #         return "\n".join(info)
            
    #     except Exception as e:
    #         return f"Error getting debug info: {str(e)}"
    
    # get_s3_debug_info.short_description = 'S3 Debug Info'
    
    def save_model(self, request, obj, form, change):
        """Override save_model to trigger OCR for new document files"""
        is_new = not obj.pk
        super().save_model(request, obj, form, change)
        
        # Only trigger OCR for new document/image files with pending auto-categorization
        if is_new and obj.file_type in ['document', 'image'] and obj.pending_auto_categorization:
            print(f"[Admin] Triggering OCR for new file {obj.id}")
            try:
                from .services import OCRService
                ocr_service = OCRService()
                result = ocr_service.process_file(obj)
                print(f"[Admin] OCR result: {result}")
            except Exception as e:
                print(f"[Admin] OCR error: {str(e)}")
                # Ensure pending flag is cleared on error
                try:
                    obj.pending_auto_categorization = False
                    if not obj.category:
                        misc_category, _ = FileCategory.objects.get_or_create(
                            name='Miscellaneous',
                            defaults={'is_default': True}
                        )
                        obj.category = misc_category
                    obj.save(update_fields=['pending_auto_categorization', 'category'])
                except Exception as inner_e:
                    print(f"[Admin] Error clearing pending flag: {inner_e}")

    def get_file_url(self, obj):
        """Generate temporary URL for admin preview"""
        storage_manager = S3StorageManager(obj.user)
        return storage_manager.get_file_url(obj.s3_key)
    
    get_file_url.short_description = 'File URL'

    def file_size_display(self, obj):
        size = obj.file_size
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024.0:
                return f"{size:.2f} {unit}"
            size /= 1024.0
    file_size_display.short_description = 'File Size'


@admin.register(FileCategory)
class FileCategoryAdmin(admin.ModelAdmin):
    list_display = ('name', 'is_default', 'created_by')
    list_filter = ('is_default',)
    search_fields = ('name',)


@admin.register(OCRResult)
class OCRResultAdmin(admin.ModelAdmin):
    list_display = ('file', 'status', 'processed_date')
    list_filter = ('status',)
    search_fields = ('file__original_filename',)


@admin.register(OCRPreference)
class OCRPreferenceAdmin(admin.ModelAdmin):
    list_display = ('user', 'preference')
    list_filter = ('preference',)


@admin.register(CardDetails)
class CardDetailsAdmin(admin.ModelAdmin):
    list_display = ('bank_name', 'card_type', 'card_holder', 'user')
    list_filter = ('card_type', 'bank_name')
    search_fields = ('card_holder', 'bank_name', 'user__email')


@admin.register(AppSubscription)
class AppSubscriptionAdmin(admin.ModelAdmin):
    list_display = ('app_name', 'subscription_type', 'user', 'status')
    list_filter = ('subscription_type', 'status')
    search_fields = ('app_name', 'user__email')

@admin.action(description='Re-process OCR for selected files')
def reprocess_ocr(modeladmin, request, queryset):
    """Custom admin action to re-trigger OCR processing."""
    processed_count = 0
    ocr_service = OCRService()
    for file in queryset.filter(file_type__in=['document', 'image']):
        try:
            # Set the pending flag to ensure categorization is attempted
            file.pending_auto_categorization = True
            file.save(update_fields=['pending_auto_categorization'])
            
            # Trigger OCR processing
            ocr_service.process_file(file)
            processed_count += 1
        except Exception as e:
            modeladmin.message_user(request, f"Error processing file {file.id}: {e}", messages.ERROR)
            


@admin.register(ExpiryDetails)
class ExpiryDetailsAdmin(admin.ModelAdmin):
    """Admin view for ExpiryDetails, which is system-managed."""
    list_display = ('get_item_name', 'document_type', 'expiry_date', 'moved_to_expired')
    list_filter = ('document_type', 'moved_to_expired', 'expiry_date')
    readonly_fields = ('document', 'card', 'subscription', 'document_type', 'expiry_date', 'moved_to_expired', 'original_category', 'expired_s3_key')

    def get_item_name(self, obj):
        if obj.document:
            return obj.document.original_filename
        if obj.card:
            return f"Card: **** {obj.card.card_number[-4:]}"
        if obj.subscription:
            return f"Subscription: {obj.subscription.app_name}"
        return "N/A"
    get_item_name.short_description = 'Item'
    
    def has_add_permission(self, request):
        return False
        
    def has_change_permission(self, request, obj=None):
        return False

================
File: apps.py
================
from django.apps import AppConfig


class FileManagementConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'file_management'
    
    def ready(self):
        from . import signals
        from .utils import create_default_categories
        import threading
        threading.Timer(5, create_default_categories).start()

================
File: forms.py
================
from django import forms
from .models import UserFile

class FileUploadForm(forms.ModelForm):
    class Meta:
        model = UserFile
        fields = ['file_type', 'file']

================
File: models.py
================
from django.db import models
from django.conf import settings
from django.contrib.auth.models import User
from storage_management.utils import S3StorageManager
import math


class OCRResult(models.Model):
    file = models.ForeignKey('UserFile', on_delete=models.CASCADE)
    text_content = models.TextField(blank=True, null=True)
    processed_date = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=20, default='pending')
    job_id = models.CharField(max_length=100, blank=True, null=True)  # Add this field

    def __str__(self):
        return f"OCR Result for {self.file.file.name}"
    

class FileCategory(models.Model):
    name = models.CharField(max_length=50)
    description = models.TextField(blank=True, null=True)
    is_default = models.BooleanField(default=False)
    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, null=True, blank=True)

    def __str__(self):
        return self.name

    class Meta:
        verbose_name_plural = "File Categories"

# class UserFile(models.Model):
#     FILE_TYPES = (
#         ('audio', 'Audio'),
#         ('document', 'Document'),
#     )
#     user = models.ForeignKey(User, on_delete=models.CASCADE, default=1)
#     file_type = models.CharField(max_length=10, choices=FILE_TYPES)
#     file = models.FileField(upload_to='uploads/')
#     upload_date = models.DateTimeField(auto_now_add=True)
#     category = models.ForeignKey(FileCategory, on_delete=models.SET_NULL, null=True)
#     user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)

#     def __str__(self):
#         return f"{self.file_type} - {self.file.name}"
class UserFile(models.Model):
    FILE_TYPES = (
        ('document', 'Document'),
        ('image', 'Image'),
        ('audio', 'Audio'),
    )

    DOCUMENT_SIDES = (
        ('single', 'Single Side'),
        ('front', 'Front Side'), 
        ('back', 'Back Side'),
    )
    
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    file_type = models.CharField(max_length=10, choices=FILE_TYPES)
    file = models.FileField(upload_to='uploads/')
    upload_date = models.DateTimeField(auto_now_add=True)
    category = models.ForeignKey('FileCategory', on_delete=models.SET_NULL, null=True, blank=True)
    is_public = models.BooleanField(default=False)
    is_favorite = models.BooleanField(default=False)
    s3_key = models.CharField(max_length=255, blank=True)
    file_size = models.BigIntegerField(default=0)
    original_filename = models.CharField(max_length=255, blank=True)
    coins_awarded = models.BooleanField(default=False)
    pending_auto_categorization = models.BooleanField(default=False)
    locked = models.BooleanField(default=False)
    locked_password = models.CharField(max_length=100, blank=True, null=True)
    document_side = models.CharField(max_length=10, choices=DOCUMENT_SIDES, default='single')
    paired_document = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True, related_name='paired_with')
    document_type_name = models.CharField(max_length=100, blank=True)
    
    def save(self, *args, **kwargs):
        # Set S3 key if not already set
        if not self.s3_key and self.file:
            storage_manager = S3StorageManager(self.user)
            filename = self.file.name.split('/')[-1]
            self.original_filename = filename
            self.s3_key = f"{storage_manager.user_prefix}{filename}"
            
        # Update file size if file is present
        if self.file and not self.file_size:
            self.file_size = self.file.size
        
        # Set pending_auto_categorization for new document files
        is_new = not self.pk
        if is_new and self.file_type in ['document', 'image'] and not self.category:
            self.pending_auto_categorization = True
            # Set default Miscellaneous category
            misc_category, _ = FileCategory.objects.get_or_create(
                name='Miscellaneous',
                defaults={'is_default': True, 'description': 'Uncategorized files'}
            )
            self.category = misc_category
            
        super().save(*args, **kwargs)
        
        # Award coins for new file uploads (keep this logic here)
        if is_new and not self.coins_awarded and self.file_size > 0:
            self._award_upload_coins()

    def _award_upload_coins(self):
        """Award coins for file upload - separated method"""
        try:
            from coin_wallet.models import CoinWallet, CoinTransaction
            
            file_size_mb = math.ceil(self.file_size / (1024 * 1024))
            if file_size_mb < 1:
                file_size_mb = 1
            
            wallet, created = CoinWallet.objects.get_or_create(user=self.user)
            
            existing_transaction = CoinTransaction.objects.filter(
                wallet=wallet,
                transaction_type='upload',
                related_file=self
            ).exists()
            
            if not existing_transaction:
                wallet.add_coins(
                    amount=file_size_mb,
                    transaction_type='upload',
                    source=f'File upload: {self.original_filename}'
                )
                
                transaction = CoinTransaction.objects.filter(
                    wallet=wallet,
                    transaction_type='upload'
                ).latest('created_at')
                transaction.related_file = self
                transaction.save()
                
                self.coins_awarded = True
                UserFile.objects.filter(pk=self.pk).update(coins_awarded=True)
        except Exception as e:
            print(f"Error awarding coins: {str(e)}")

    def get_file_url(self):
        """Get presigned URL for file access"""
        if not self.s3_key:
            return None
            
        storage_manager = S3StorageManager(self.user)
        return storage_manager.get_file_url(self.s3_key)

    def get_download_url(self):
        """Get presigned URL for file download"""
        if not self.s3_key:
            return None
            
        storage_manager = S3StorageManager(self.user)
        return storage_manager.get_file_url(
            self.s3_key, 
            response_content_disposition=f'attachment; filename="{self.original_filename}"'
        )

    def get_file_size_display(self):
        """Return human-readable file size"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if self.file_size < 1024:
                return f"{self.file_size:.2f} {unit}"
            self.file_size /= 1024
        return f"{self.file_size:.2f} TB"

    def delete(self, *args, **kwargs):
        """Override delete to remove file from S3 with enhanced error handling"""
        s3_deletion_success = False
        
        # Try multiple S3 key variations to find and delete the file
        if self.s3_key or self.file:
            try:
                storage_manager = S3StorageManager(self.user)
            
                # List of possible S3 keys to try
                possible_keys = []
                
                # Add current s3_key if it exists
                if self.s3_key:
                    possible_keys.append(self.s3_key)
                
                # Add file.name if it exists and is different
                if self.file and self.file.name and self.file.name != self.s3_key:
                    possible_keys.append(self.file.name)
                
                # Add variations based on original filename
                if self.original_filename:
                    possible_keys.extend([
                        f"uploads/{self.original_filename}",
                        f"user_{self.user.id}/{self.original_filename}",
                        self.original_filename
                    ])
                
                # Remove duplicates while preserving order
                seen = set()
                unique_keys = []
                for key in possible_keys:
                    if key and key not in seen:
                        seen.add(key)
                        unique_keys.append(key)
                
                print(f"[Delete] Attempting to delete file {self.id}: {self.original_filename}")
                print(f"[Delete] Trying S3 keys: {unique_keys}")
                
                # Try each key until one succeeds
                for key in unique_keys:
                    try:
                        # First, check if file exists in S3
                        if storage_manager.file_exists(key):
                            print(f"[Delete] Found file with key: {key}")
                            storage_manager.delete_file(key)
                            print(f"[Delete] Successfully deleted file from S3: {key}")
                            s3_deletion_success = True
                            break
                        else:
                            print(f"[Delete] File not found with key: {key}")
                    except Exception as key_error:
                        print(f"[Delete] Failed to delete with key '{key}': {str(key_error)}")
                        continue
                
                if not s3_deletion_success:
                    print(f"[Delete] Warning: Could not find file in S3 with any key variation")
                    print(f"[Delete] File may have been already deleted or moved")
            
            except Exception as e:
                print(f"[Delete] Error during S3 deletion process: {str(e)}")
        
        # Always delete the database record, even if S3 deletion failed
        print(f"[Delete] Deleting database record for file {self.id}")
        super().delete(*args, **kwargs)
        
        if s3_deletion_success:
            print(f"[Delete] Successfully deleted file {self.id} from both S3 and database")
        else:
            print(f"[Delete] Deleted database record for file {self.id}, but S3 file was not found")

    def __str__(self):
        return f"{self.file_type} - {self.original_filename}"

    def get_document_pair(self):
        """Get both sides of a paired document"""
        if self.document_side == 'single':
            return {'single': self}
        
        pair = {}
        if self.document_side == 'front':
            pair['front'] = self
            pair['back'] = self.paired_document
        elif self.document_side == 'back':
            pair['back'] = self
            pair['front'] = self.paired_document
            
        return pair
    
    def has_pair(self):
        """Check if document has a paired document"""
        return self.paired_document is not None

    class Meta:
        ordering = ['-upload_date']
        verbose_name = 'User File'
        verbose_name_plural = 'User Files'

class CardDetails(models.Model):
    CARD_TYPES = (
        ('credit', 'Credit Card'),
        ('debit', 'Debit Card')
    )
    
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    card_type = models.CharField(max_length=10, choices=CARD_TYPES)
    bank_name = models.CharField(max_length=100)
    card_number = models.CharField(max_length=16)  # Will be encrypted
    card_holder = models.CharField(max_length=100)
    expiry_month = models.CharField(max_length=2)
    expiry_year = models.CharField(max_length=4)
    cvv = models.CharField(max_length=4)  # Will be encrypted
    created_at = models.DateTimeField(auto_now_add=True)
    extracted_from_doc = models.ForeignKey('UserFile', null=True, blank=True, on_delete=models.SET_NULL)

    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.bank_name} - {self.card_type} (**** {self.card_number[-4:]})"

class AppSubscription(models.Model):
    STATUS_CHOICES = (
        ('active', 'Active'),
        ('expired', 'Expired'),
        ('canceled', 'Canceled')
    )

    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    app_name = models.CharField(max_length=100)
    subscription_type = models.CharField(max_length=50)  # e.g., "Monthly", "Annual"
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    start_date = models.DateField()
    end_date = models.DateField()
    auto_renewal = models.BooleanField(default=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='active')
    payment_method = models.ForeignKey(CardDetails, on_delete=models.SET_NULL, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    extracted_from_doc = models.ForeignKey('UserFile', null=True, blank=True, on_delete=models.SET_NULL)
    
    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.app_name} - {self.subscription_type} ({self.status})"
    
    @property
    def current_status(self):
        from datetime import date
        today = date.today()
        
        if self.end_date < today and not self.auto_renewal:
            return 'expired'
        elif self.end_date < today and self.auto_renewal:
            # If auto-renewal is on, consider it active even after end_date
            return 'active'
        else:
            return 'active'

# For encrypting sensitive data
class EncryptedCardField(models.CharField):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def from_db_value(self, value, expression, connection):
        if value is None:
            return value
        return self.decrypt_value(value)

    def to_python(self, value):
        if value is None:
            return value
        return self.decrypt_value(value)

    def get_prep_value(self, value):
        if value is None:
            return value
        return self.encrypt_value(value)

    @staticmethod
    def encrypt_value(value):
        #TODO Implement encryption logic
        pass

    @staticmethod
    def decrypt_value(value):
        #TODO Implement decryption logic
        pass

class ExpiryDetails(models.Model):
    DOCUMENT_TYPE_CHOICES = (
        ('document', 'Document'),
        ('card', 'Card'),
        ('subscription', 'Subscription')
    )
    
    document = models.ForeignKey('UserFile', on_delete=models.CASCADE, null=True, blank=True)
    card = models.ForeignKey('CardDetails', on_delete=models.CASCADE, null=True, blank=True)
    subscription = models.ForeignKey('AppSubscription', on_delete=models.CASCADE, null=True, blank=True)
    document_type = models.CharField(max_length=20, choices=DOCUMENT_TYPE_CHOICES)
    expiry_date = models.DateField()
    moved_to_expired = models.BooleanField(default=False)
    original_category = models.CharField(max_length=100, blank=True)
    expired_s3_key = models.CharField(max_length=255, blank=True)
    
    def __str__(self):
        if self.document:
            return f"Document Expiry: {self.document.file.name}"
        elif self.card:
            return f"Card Expiry: {self.card.card_number[-4:]}"
        else:
            return f"Subscription Expiry: {self.subscription.app_name}"

# Create the expired documents category
def create_expired_category():
    FileCategory.objects.get_or_create(
        name='EXPIRED_DOCS',
        defaults={
            'is_default': True,
            'description': 'Category for expired documents, cards, and subscriptions'
        }
    )


class OCRPreference(models.Model):
    OCR_CHOICES = (
        ('all', 'Process OCR on all files'),
        ('selected', 'Process OCR only on selected files'),
        ('none', 'Do not process OCR on any files')
    )
    
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    preference = models.CharField(max_length=10, choices=OCR_CHOICES, default='all')
    
    def __str__(self):
        return f"{self.user.username}'s OCR preference: {self.get_preference_display()}"

    



locked = models.BooleanField(default=False)
locked_password = models.CharField(max_length=100, blank=True, null=True)

================
File: serializers.py
================
from rest_framework import serializers
from .models import UserFile, FileCategory, CardDetails, AppSubscription, OCRResult


class FileCategorySerializer(serializers.ModelSerializer):
    class Meta:
        model = FileCategory
        fields = ['id', 'name', 'description', 'is_default']

class UserFileSerializer(serializers.ModelSerializer):
    category = FileCategorySerializer(read_only=True)
    category_id = serializers.IntegerField(write_only=True, required=False)
    file_url = serializers.SerializerMethodField()
    file_size_display = serializers.SerializerMethodField()
    document_pair = serializers.SerializerMethodField()
    has_pair = serializers.SerializerMethodField()

    class Meta:
        model = UserFile
        fields = [
            'id', 'file_type', 'file', 'upload_date', 'category', 
            'category_id', 'is_public', 'original_filename', 
            'file_size', 'file_url', 'file_size_display',
            'document_side', 'paired_document', 'document_type_name',
            'document_pair', 'has_pair'
        ]
        read_only_fields = ['upload_date', 'file_size', 'original_filename']

    def get_file_url(self, obj):
        return obj.get_file_url()

    def get_file_size_display(self, obj):
        return obj.get_file_size_display()
    
    def get_document_pair(self, obj):
        """Get paired document information"""
        if obj.document_side == 'single':
            return None
            
        pair_data = {}
        pair = obj.get_document_pair()
        
        for side, doc in pair.items():
            if doc:
                pair_data[side] = {
                    'id': doc.id,
                    'file_url': doc.get_file_url(),
                    'original_filename': doc.original_filename
                }
        
        return pair_data if pair_data else None
    
    def get_has_pair(self, obj):
        return obj.has_pair()

class OCRResultSerializer(serializers.ModelSerializer):
    class Meta:
        model = OCRResult
        fields = ['id', 'text_content', 'processed_date', 'status', 'job_id']
        read_only_fields = ['processed_date', 'status', 'job_id']

class FileUploadSerializer(serializers.Serializer):
    file = serializers.FileField()
    file_type = serializers.ChoiceField(choices=UserFile.FILE_TYPES)
    category_id = serializers.IntegerField(required=False)

class FileSearchSerializer(serializers.Serializer):
    query = serializers.CharField(required=False)
    file_type = serializers.ChoiceField(choices=UserFile.FILE_TYPES, required=False)
    category = serializers.IntegerField(required=False)
    date_from = serializers.DateField(required=False)
    date_to = serializers.DateField(required=False)

class CardDetailsSerializer(serializers.ModelSerializer):
    class Meta:
        model = CardDetails
        fields = ['id', 'card_type', 'bank_name', 'card_number', 
                'card_holder', 'expiry_month', 'expiry_year', 'cvv']
        read_only_fields = ['id']
        extra_kwargs = {
            'cvv': {'write_only': True}  # CVV should never be sent back
        }

    def validate_card_number(self, value):
        # Remove any spaces or dashes
        value = ''.join(filter(str.isdigit, value))
        if not len(value) in [15, 16]:
            raise serializers.ValidationError("Invalid card number length")
        return value

    def validate_expiry_month(self, value):
        if not (1 <= int(value) <= 12):
            raise serializers.ValidationError("Invalid expiry month")
        return value.zfill(2)

    def validate_expiry_year(self, value):
        from datetime import datetime
        current_year = datetime.now().year
        year = int(value)
        if not (current_year <= year <= current_year + 20):
            raise serializers.ValidationError("Invalid expiry year")
        return str(year)

    def create(self, validated_data):
        # Get the user from the context
        user = self.context['request'].user
        validated_data['user'] = user
        return super().create(validated_data)

class AppSubscriptionSerializer(serializers.ModelSerializer):
    payment_method = CardDetailsSerializer(read_only=True)
    payment_method_id = serializers.IntegerField(write_only=True, required=False)

    class Meta:
        model = AppSubscription
        fields = ['id', 'app_name', 'subscription_type', 'amount', 
                'start_date', 'end_date', 'auto_renewal', 'status',
                'payment_method', 'payment_method_id']
        read_only_fields = ['id']

    def validate(self, data):
        if 'start_date' in data and 'end_date' in data:
            if data['start_date'] > data['end_date']:
                raise serializers.ValidationError({
                    'end_date': 'End date must be after start date'
                })
        return data

    def create(self, validated_data):
        payment_method_id = validated_data.pop('payment_method_id', None)
        if payment_method_id:
            try:
                payment_method = CardDetails.objects.get(
                    id=payment_method_id,
                    user=self.context['request'].user
                )
                validated_data['payment_method'] = payment_method
            except CardDetails.DoesNotExist:
                raise serializers.ValidationError({
                    'payment_method_id': 'Invalid payment method'
                })
        
        return super().create(validated_data)
    
class MobileFileUploadSerializer(serializers.Serializer):
    file = serializers.FileField()
    file_type = serializers.ChoiceField(choices=['document', 'image'])
    category_id = serializers.IntegerField(required=False)
    category = serializers.IntegerField(required=False)  # For backward compatibility
    
    def validate(self, data):
        # Handle both category fields
        category_legacy = data.pop('category', None) # Get it, or None if not present
        if category_legacy is not None and 'category_id' not in data:
            data['category_id'] = category_legacy
        return data

================
File: services.py
================
from datetime import date
import boto3, time
from django.db import models
from django.conf import settings
from .models import ExpiryDetails, FileCategory, UserFile, CardDetails, AppSubscription, OCRResult, OCRPreference
from .utils import extract_text_from_document, FileCategorizationService

class ExpiryManagementService:
    def __init__(self):
        self.s3_client = boto3.client(
            's3',
            aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
            aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
            region_name=settings.AWS_S3_REGION_NAME
        )
        self.bucket_name = settings.AWS_STORAGE_BUCKET_NAME

    def check_and_move_expired_items(self):
        today = date.today()
        expired_category, _ = FileCategory.objects.get_or_create(
            name='EXPIRED_DOCS',
            defaults={'is_default': True}
        )

        # Check cards
        expired_cards = CardDetails.objects.filter(
            expiry_year__lt=today.year,
            expiry_month__lt=today.month
        )
        for card in expired_cards:
            self._handle_expired_card(card, expired_category)

        # Check subscriptions
        expired_subscriptions = AppSubscription.objects.filter(
            end_date__lt=today,
            auto_renewal=False
        )
        for subscription in expired_subscriptions:
            self._handle_expired_subscription(subscription, expired_category)

    def _handle_expired_card(self, card, expired_category):
        if not ExpiryDetails.objects.filter(card=card).exists():
            # Create expiry record
            ExpiryDetails.objects.create(
                card=card,
                document_type='card',
                expiry_date=date(int(card.expiry_year), int(card.expiry_month), 1),
                original_category='Cards'
            )

    def _handle_expired_subscription(self, subscription, expired_category):
        if not ExpiryDetails.objects.filter(subscription=subscription).exists():
            # Create expiry record
            ExpiryDetails.objects.create(
                subscription=subscription,
                document_type='subscription',
                expiry_date=subscription.end_date,
                original_category='Subscriptions'
            )
            
            # Update subscription status
            subscription.status = 'expired'
            subscription.save()

    def move_file_to_expired_folder(self, s3_key, expired_category):
        """Move file to expired folder in S3"""
        new_key = f"expired/{s3_key}"
        try:
            # Copy the object to new location
            self.s3_client.copy_object(
                Bucket=self.bucket_name,
                CopySource={'Bucket': self.bucket_name, 'Key': s3_key},
                Key=new_key
            )
            # Delete the original
            self.s3_client.delete_object(
                Bucket=self.bucket_name,
                Key=s3_key
            )
            return new_key
        except Exception as e:
            print(f"Error moving file to expired folder: {str(e)}")
            return None

    def get_expired_items(self, user):
        """Get all expired items for a user"""
        return ExpiryDetails.objects.filter(
            models.Q(document__user=user) |
            models.Q(card__user=user) |
            models.Q(subscription__user=user)
        )


class OCRService:
    def __init__(self):
        self.textract_client = boto3.client(
            'textract',
            aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
            aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
            region_name=settings.AWS_S3_REGION_NAME
        )
        self.s3_client = boto3.client(
            's3',
            aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
            aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
            region_name=settings.AWS_S3_REGION_NAME
        )
        self.categorization_service = FileCategorizationService()

    def _verify_s3_object_exists(self, s3_key):
        """Verify that the S3 object exists before processing"""
        try:
            print(f"[OCR Service] Checking S3 object: {s3_key}")
            print(f"[OCR Service] Bucket: {settings.AWS_STORAGE_BUCKET_NAME}")
            
            response = self.s3_client.head_object(
                Bucket=settings.AWS_STORAGE_BUCKET_NAME,
                Key=s3_key
            )
            
            print(f"[OCR Service] S3 object found - Size: {response['ContentLength']} bytes")
            return True
            
        except self.s3_client.exceptions.NoSuchKey:
            print(f"[OCR Service] S3 object not found: {s3_key}")
            return False
        except Exception as e:
            print(f"[OCR Service] Error checking S3 object: {str(e)}")
            return False

    def _normalize_s3_key(self, user_file):
        """Normalize and fix S3 key if needed"""
        original_key = user_file.s3_key
        
        # Try different possible S3 key formats
        possible_keys = [
            original_key,  # Original key
            user_file.file.name,  # File field name
            f"uploads/{user_file.original_filename}",  # uploads/ prefix
            f"user_{user_file.user.id}/{user_file.original_filename}",  # user prefix
            user_file.original_filename  # Just filename
        ]
        
        print(f"[OCR Service] Trying to find S3 object with these keys:")
        for i, key in enumerate(possible_keys):
            if key:  # Skip empty keys
                print(f"[OCR Service]   {i+1}. {key}")
                if self._verify_s3_object_exists(key):
                    if key != original_key:
                        print(f"[OCR Service] Found working S3 key: {key}")
                        # Update the file with the correct S3 key
                        user_file.s3_key = key
                        user_file.save(update_fields=['s3_key'])
                    return key
        
        raise Exception(f"S3 object not found with any key variation for file {user_file.id}")

    def process_file(self, user_file):
        """Main entry point for OCR processing with S3 debugging"""
        print(f"[OCR Service] Starting OCR for file: {user_file.id}")
        print(f"[OCR Service] File details:")
        print(f"  - Original filename: {user_file.original_filename}")
        print(f"  - File field: {user_file.file.name}")
        print(f"  - S3 key: {user_file.s3_key}")
        print(f"  - File type: {user_file.file_type}")
        
        try:
            # Check OCR preferences
            ocr_pref, _ = OCRPreference.objects.get_or_create(user=user_file.user)
            if ocr_pref.preference == 'none':
                print(f"[OCR Service] OCR disabled for user {user_file.user.id}")
                self._clear_pending_flag(user_file)
                return {'status': 'skipped', 'reason': 'OCR disabled by user'}

            # Verify and normalize S3 key
            try:
                s3_key = self._normalize_s3_key(user_file)
                print(f"[OCR Service] Using S3 key: {s3_key}")
            except Exception as s3_error:
                print(f"[OCR Service] S3 key error: {str(s3_error)}")
                self._handle_error(user_file, f"S3 access error: {str(s3_error)}")
                return {'status': 'error', 'error': str(s3_error)}

            # Create OCR result record
            ocr_result, created = OCRResult.objects.get_or_create(
                file=user_file,
                defaults={'status': 'pending'}
            )
            print(f"[OCR Service] OCR result {'created' if created else 'found'}: {ocr_result.id}")

            # Get file extension
            file_extension = self._get_file_extension(user_file)
            print(f"[OCR Service] Processing file type: {file_extension}")
            
            # Process based on file type
            if file_extension in ['txt', 'docx', 'md']:
                return self._process_text_file(user_file, ocr_result, file_extension)
            elif file_extension in ['jpg', 'jpeg', 'png']:
                return self._process_image_file(user_file, ocr_result)
            elif file_extension == 'pdf':
                return self._process_pdf_file(user_file, ocr_result)
            else:
                print(f"[OCR Service] Unsupported file type: {file_extension}")
                self._mark_as_not_applicable(user_file, ocr_result)
                return {'status': 'not_applicable', 'reason': 'Unsupported file type'}

        except Exception as e:
            print(f"[OCR Service] Error processing file {user_file.id}: {str(e)}")
            import traceback
            traceback.print_exc()
            self._handle_error(user_file, str(e))
            return {'status': 'error', 'error': str(e)}

    def _process_text_file(self, user_file, ocr_result, file_extension):
        """Process text-based files (txt, docx, md)"""
        try:
            print(f"[OCR Service] Processing text file: {file_extension}")
            text_content = extract_text_from_document(user_file.s3_key, file_extension)
            print(f"[OCR Service] Extracted text length: {len(text_content) if text_content else 0}")
            
            if text_content:
                # Update OCR result
                ocr_result.text_content = text_content
                ocr_result.status = 'completed'
                ocr_result.save()
                print(f"[OCR Service] OCR result updated to completed")
                
                # Categorize and update file
                category_result = self._categorize_file(user_file, text_content)
                print(f"[OCR Service] Categorization result: {category_result}")
                
                return {
                    'status': 'completed',
                    'text_length': len(text_content),
                    'category': user_file.category.name if user_file.category else 'Miscellaneous',
                    'category_changed': category_result.get('changed', False)
                }
            else:
                raise Exception("No text content extracted")
                
        except Exception as e:
            print(f"[OCR Service] Error processing text file: {str(e)}")
            import traceback
            traceback.print_exc()
            self._handle_error(user_file, str(e))
            return {'status': 'error', 'error': str(e)}

    def _process_image_file(self, user_file, ocr_result):
        """Process image files using Textract"""
        try:
            print(f"[OCR Service] Processing image file with Textract")
            
            response = self.textract_client.detect_document_text(
                Document={
                    'S3Object': {
                        'Bucket': settings.AWS_STORAGE_BUCKET_NAME,
                        'Name': user_file.s3_key
                    }
                }
            )
            
            # Extract text lines
            extracted_lines = [
                item['Text'] for item in response['Blocks'] 
                if item['BlockType'] == 'LINE'
            ]
            text_content = '\n'.join(extracted_lines)
            print(f"[OCR Service] Extracted text length: {len(text_content)}")
            
            # Update OCR result
            ocr_result.text_content = text_content
            ocr_result.status = 'completed'
            ocr_result.save()
            
            # Categorize and update file
            category_result = self._categorize_file(user_file, text_content)
            print(f"[OCR Service] Categorization result: {category_result}")
            
            return {
                'status': 'completed',
                'text_length': len(text_content),
                'category': user_file.category.name if user_file.category else 'Miscellaneous',
                'category_changed': category_result.get('changed', False)
            }
            
        except Exception as e:
            print(f"[OCR Service] Error processing image file: {str(e)}")
            import traceback
            traceback.print_exc()
            self._handle_error(user_file, str(e))
            return {'status': 'error', 'error': str(e)}

    def _process_pdf_file(self, user_file, ocr_result):
        """Process PDF files using async Textract"""
        try:
            print(f"[OCR Service] Starting async PDF processing")
            
            # Check if job already exists
            if ocr_result.job_id and ocr_result.status == 'processing':
                job_status = self._check_textract_job(ocr_result.job_id)
                if job_status == 'SUCCEEDED':
                    return self._complete_pdf_processing(user_file, ocr_result)
                elif job_status == 'FAILED':
                    raise Exception("Previous Textract job failed")
                else:
                    return {'status': 'processing', 'job_id': ocr_result.job_id}
            
            # Start new Textract job
            response = self.textract_client.start_document_analysis(
                DocumentLocation={
                    'S3Object': {
                        'Bucket': settings.AWS_STORAGE_BUCKET_NAME,
                        'Name': user_file.s3_key
                    }
                },
                FeatureTypes=['TABLES', 'FORMS']
            )
            
            job_id = response['JobId']
            
            # Update OCR result
            ocr_result.job_id = job_id
            ocr_result.status = 'processing'
            ocr_result.save()
            
            print(f"[OCR Service] Started Textract job: {job_id}")
            
            # Try to wait and complete immediately (for smaller PDFs)
            return self._wait_for_pdf_completion(user_file, ocr_result, max_wait=30)
            
        except Exception as e:
            print(f"[OCR Service] Error processing PDF file: {str(e)}")
            import traceback
            traceback.print_exc()
            self._handle_error(user_file, str(e))
            return {'status': 'error', 'error': str(e)}

    def _wait_for_pdf_completion(self, user_file, ocr_result, max_wait=30):
        """Wait for PDF processing to complete (up to max_wait seconds)"""
        start_time = time.time()
        
        while time.time() - start_time < max_wait:
            try:
                job_status = self._check_textract_job(ocr_result.job_id)
                print(f"[OCR Service] Job {ocr_result.job_id} status: {job_status}")
                
                if job_status == 'SUCCEEDED':
                    return self._complete_pdf_processing(user_file, ocr_result)
                elif job_status == 'FAILED':
                    raise Exception("Textract job failed")
                
                # Wait before checking again
                time.sleep(2)
                
            except Exception as e:
                print(f"[OCR Service] Error checking job status: {str(e)}")
                break
        
        # If we reach here, job is still processing
        return {'status': 'processing', 'job_id': ocr_result.job_id}

    def _check_textract_job(self, job_id):
        """Check status of Textract job"""
        try:
            response = self.textract_client.get_document_analysis(JobId=job_id)
            return response['JobStatus']
        except Exception as e:
            print(f"[OCR Service] Error checking job {job_id}: {str(e)}")
            return 'FAILED'

    def _complete_pdf_processing(self, user_file, ocr_result):
        """Complete PDF processing when Textract job succeeds"""
        try:
            print(f"[OCR Service] Completing PDF processing for job: {ocr_result.job_id}")
            response = self.textract_client.get_document_analysis(JobId=ocr_result.job_id)
            
            # Extract text from all pages
            text_content = ""
            blocks = response.get('Blocks', [])
            
            # Handle pagination
            page_count = 1
            while True:
                lines = [block['Text'] for block in blocks if block['BlockType'] == 'LINE']
                text_content += '\n'.join(lines) + '\n'
                print(f"[OCR Service] Processed page {page_count}, lines: {len(lines)}")
                
                # Check for more pages
                next_token = response.get('NextToken')
                if not next_token:
                    break
                    
                response = self.textract_client.get_document_analysis(
                    JobId=ocr_result.job_id,
                    NextToken=next_token
                )
                blocks = response.get('Blocks', [])
                page_count += 1
            
            text_content = text_content.strip()
            print(f"[OCR Service] Total text extracted: {len(text_content)} characters from {page_count} pages")
            
            # Update OCR result
            ocr_result.text_content = text_content
            ocr_result.status = 'completed'
            ocr_result.save()
            
            # Categorize and update file
            category_result = self._categorize_file(user_file, text_content)
            print(f"[OCR Service] Final categorization result: {category_result}")
            
            return {
                'status': 'completed',
                'text_length': len(text_content),
                'category': user_file.category.name if user_file.category else 'Miscellaneous',
                'category_changed': category_result.get('changed', False)
            }
            
        except Exception as e:
            print(f"[OCR Service] Error completing PDF processing: {str(e)}")
            import traceback
            traceback.print_exc()
            self._handle_error(user_file, str(e))
            return {'status': 'error', 'error': str(e)}

    def _categorize_file(self, user_file, text_content):
        """ENHANCED categorization with detailed logging"""
        try:
            original_category = user_file.category.name if user_file.category else 'None'
            print(f"\n[CATEGORIZATION] ===== Starting categorization =====")
            print(f"[CATEGORIZATION] File: {user_file.original_filename}")
            print(f"[CATEGORIZATION] Original category: {original_category}")
            print(f"[CATEGORIZATION] Pending auto-categorization: {user_file.pending_auto_categorization}")
            print(f"[CATEGORIZATION] Text content length: {len(text_content)}")
            
            # Show first 300 chars of text for debugging
            if text_content:
                preview_text = text_content[:300].replace('\n', ' ').strip()
                print(f"[CATEGORIZATION] Text preview: {preview_text}...")
            
            # ALWAYS attempt categorization if text exists and file is in Miscellaneous or has pending flag
            should_categorize = (
                text_content and 
                len(text_content.strip()) > 10 and  # Ensure meaningful text
                (
                    user_file.pending_auto_categorization or 
                    (user_file.category and user_file.category.name == 'Miscellaneous')
                )
            )
            
            print(f"[CATEGORIZATION] Should categorize: {should_categorize}")
            
            category_changed = False
            analysis = None
            
            if should_categorize:
                print(f"[CATEGORIZATION] Analyzing text for categorization...")
                analysis = self.categorization_service.analyze_file_content(text_content)
                
                print(f"[CATEGORIZATION] Analysis result:")
                print(f"  - Suggested category: {analysis['category']}")
                print(f"  - Confidence: {analysis['confidence']:.2f}%")
                print(f"  - Total matches found: {len(analysis.get('matches', {}))}")
                
                # Show detailed match breakdown
                if analysis.get('matches'):
                    print(f"[CATEGORIZATION] Match breakdown:")
                    for category, matches in analysis['matches'].items():
                        total_score = sum(match['count'] for match in matches)
                        exact_matches = sum(1 for match in matches if match['exact_match'])
                        print(f"    {category}: {total_score} total, {exact_matches} exact matches")
                        
                        # Show top keywords for debugging
                        top_matches = sorted(matches, key=lambda x: x['count'], reverse=True)[:3]
                        keywords = [f"{m['keyword']}({m['count']})" for m in top_matches]
                        print(f"      Top keywords: {', '.join(keywords)}")
                
                # Use lower confidence threshold (25% instead of 40%)
                confidence_threshold = 25
                print(f"[CATEGORIZATION] Confidence threshold: {confidence_threshold}%")
                
                if analysis['confidence'] >= confidence_threshold:
                    suggested_category_name = analysis['category']
                    
                    # Don't change if it's the same category
                    if suggested_category_name != original_category:
                        category, created = FileCategory.objects.get_or_create(
                            name=suggested_category_name,
                            defaults={'is_default': True}
                        )
                        
                        print(f"[CATEGORIZATION] ✓ CHANGING category from '{original_category}' to '{suggested_category_name}'")
                        user_file.category = category
                        category_changed = True
                        
                        # Send notification email (optional)
                        try:
                            from django.core.mail import send_mail
                            send_mail(
                                'File Auto-Categorized',
                                f'Your file "{user_file.original_filename}" has been automatically categorized as "{suggested_category_name}" based on its content.',
                                settings.DEFAULT_FROM_EMAIL,
                                [user_file.user.email],
                                fail_silently=True,
                            )
                            print(f"[CATEGORIZATION] ✓ Notification email sent")
                        except Exception as email_error:
                            print(f"[CATEGORIZATION] Email notification failed: {str(email_error)}")
                            
                    else:
                        print(f"[CATEGORIZATION] = Suggested category same as original, no change needed")
                        category_changed = False
                else:
                    print(f"[CATEGORIZATION] ✗ Confidence too low ({analysis['confidence']:.2f}%), keeping original category")
                    category_changed = False
            else:
                print(f"[CATEGORIZATION] - Auto-categorization skipped")
                if not text_content:
                    print(f"[CATEGORIZATION]   Reason: No text content")
                elif len(text_content.strip()) <= 10:
                    print(f"[CATEGORIZATION]   Reason: Text too short")
                elif not user_file.pending_auto_categorization and user_file.category.name != 'Miscellaneous':
                    print(f"[CATEGORIZATION]   Reason: User-selected category")
            
            # Always clear pending flag and save
            user_file.pending_auto_categorization = False
            user_file.save()
            print(f"[CATEGORIZATION] File saved with final category: {user_file.category.name}")
            print(f"[CATEGORIZATION] ===== Categorization complete =====\n")
            
            return {
                'changed': category_changed,
                'final_category': user_file.category.name if user_file.category else 'Miscellaneous',
                'analysis': analysis,
                'confidence': analysis['confidence'] if analysis else 0
            }
            
        except Exception as e:
            print(f"[CATEGORIZATION] ✗ Error categorizing file: {str(e)}")
            import traceback
            traceback.print_exc()
            self._clear_pending_flag(user_file)
            return {'changed': False, 'error': str(e)}

    def _handle_error(self, user_file, error_message):
        """Handle OCR processing errors"""
        try:
            print(f"[OCR Service] Handling error for file {user_file.id}: {error_message}")
            
            # Update or create OCR result
            ocr_result, created = OCRResult.objects.get_or_create(
                file=user_file,
                defaults={'status': 'failed', 'text_content': f'Error: {error_message}'}
            )
            if not created:
                ocr_result.status = 'failed'
                ocr_result.text_content = f'Error: {error_message}'
                ocr_result.save()
            
            # Clear pending flag and ensure file has category
            self._clear_pending_flag(user_file)
            
        except Exception as e:
            print(f"[OCR Service] Error handling error: {str(e)}")

    def _mark_as_not_applicable(self, user_file, ocr_result):
        """Mark file as not applicable for OCR"""
        ocr_result.status = 'not_applicable'
        ocr_result.text_content = 'OCR not applicable for this file type'
        ocr_result.save()
        self._clear_pending_flag(user_file)

    def _clear_pending_flag(self, user_file):
        """Clear pending flag and ensure file has category"""
        try:
            if not user_file.category:
                misc_category, _ = FileCategory.objects.get_or_create(
                    name='Miscellaneous',
                    defaults={'is_default': True}
                )
                user_file.category = misc_category
            
            user_file.pending_auto_categorization = False
            user_file.save()
            print(f"[OCR Service] Cleared pending flag for file {user_file.id}")
            
        except Exception as e:
            print(f"[OCR Service] Error clearing pending flag: {str(e)}")

    def _get_file_extension(self, user_file):
        """Get file extension from original filename"""
        if user_file.original_filename:
            return user_file.original_filename.split('.')[-1].lower()
        elif user_file.file.name:
            return user_file.file.name.split('.')[-1].lower()
        return ''

    def check_pending_jobs(self):
        """Check and complete pending PDF jobs"""
        print(f"[OCR Service] Checking pending jobs...")
        pending_jobs = OCRResult.objects.filter(
            status='processing',
            job_id__isnull=False
        ).select_related('file')
        
        print(f"[OCR Service] Found {pending_jobs.count()} pending jobs")
        
        for ocr_result in pending_jobs:
            try:
                job_status = self._check_textract_job(ocr_result.job_id)
                
                if job_status == 'SUCCEEDED':
                    result = self._complete_pdf_processing(ocr_result.file, ocr_result)
                    print(f"[OCR Service] Completed pending job: {ocr_result.job_id} - {result}")
                elif job_status == 'FAILED':
                    self._handle_error(ocr_result.file, "Textract job failed")
                    print(f"[OCR Service] Failed pending job: {ocr_result.job_id}")
                else:
                    print(f"[OCR Service] Job {ocr_result.job_id} still {job_status}")
                    
            except Exception as e:
                print(f"[OCR Service] Error checking pending job {ocr_result.job_id}: {str(e)}")

================
File: signals.py
================
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.core.mail import send_mail
from django.conf import settings

from .models import OCRResult, UserFile, FileCategory

# @receiver(post_save, sender=OCRResult)
# def notify_category_change(sender, instance, created, **kwargs):
#     """
#     Send a notification when OCR completes and changes a file's category
#     """
#     # Only proceed if the result is completed and has text
#     if instance.status == 'completed' and instance.text_content:
#         try:
#             user_file = instance.file
            
#             # OCR processing has just been completed - check if categorization has changed
#             if hasattr(user_file, '_original_category_id') and user_file._original_category_id:
#                 original_category_id = user_file._original_category_id
#                 current_category_id = user_file.category_id if user_file.category else None
                
#                 # If category changed, notify user
#                 if original_category_id != current_category_id:
#                     try:
#                         original_category = FileCategory.objects.get(id=original_category_id)
#                         current_category = FileCategory.objects.get(id=current_category_id) if current_category_id else None
                        
#                         if current_category:
#                             # Send email notification
#                             send_mail(
#                                 'File Category Changed',
#                                 f'Your file "{user_file.original_filename}" has been moved from "{original_category.name}" to "{current_category.name}" based on its content.',
#                                 settings.DEFAULT_FROM_EMAIL,
#                                 [user_file.user.email],
#                                 fail_silently=True,
#                             )
#                     except Exception as e:
#                         print(f"Error in category change notification: {str(e)}")
#         except Exception as e:
#             print(f"Error in OCR result signal handler: {str(e)}")



from django.db.models.signals import post_save, m2m_changed
from django.dispatch import receiver
from .models import UserFile

@receiver(post_save, sender=UserFile)
def trigger_ocr_for_paired_documents(sender, instance, created, **kwargs):
    """Trigger OCR when documents are paired"""
    if not created and instance.paired_document:
        # Check if both documents need OCR
        files_to_process = []
        
        # Check current file
        if instance.file_type in ['document', 'image']:
            try:
                from .models import OCRResult
                ocr_result = OCRResult.objects.get(file=instance)
                if ocr_result.status not in ['completed', 'processing']:
                    files_to_process.append(instance)
            except OCRResult.DoesNotExist:
                files_to_process.append(instance)
        
        # Check paired document
        paired_doc = instance.paired_document
        if paired_doc and paired_doc.file_type in ['document', 'image']:
            try:
                from .models import OCRResult
                ocr_result = OCRResult.objects.get(file=paired_doc)
                if ocr_result.status not in ['completed', 'processing']:
                    files_to_process.append(paired_doc)
            except OCRResult.DoesNotExist:
                files_to_process.append(paired_doc)
        
        # Process OCR for files that need it
        if files_to_process:
            try:
                from .services import OCRService
                ocr_service = OCRService()
                for file_obj in files_to_process:
                    print(f"[Signal] Triggering OCR for paired document: {file_obj.id}")
                    ocr_service.process_file(file_obj)
            except Exception as e:
                print(f"[Signal] Error processing paired document OCR: {str(e)}")

================
File: tasks.py
================
from celery import shared_task
import logging
import os
import requests
import pytesseract
from PIL import Image
from io import BytesIO
from django.core.files.base import ContentFile
from django.core.files.storage import default_storage
from django.utils import timezone
from .models import OCRResult

logger = logging.getLogger(__name__)

@shared_task
def process_ocr(ocr_id, file_url):
    """
    Process OCR on a document file
    
    Args:
        ocr_id (int): ID of the OCRResult object
        file_url (str): Presigned URL to download the file
    
    Returns:
        dict: Result of OCR processing
    """
    try:
        logger.info(f"Starting OCR processing for document ID: {ocr_id}")
        
        # Get OCR record
        try:
            ocr_record = OCRResult.objects.get(id=ocr_id)
        except OCRResult.DoesNotExist:
            logger.error(f"OCR record with ID {ocr_id} not found")
            return {"status": "error", "message": "OCR record not found"}
        
        # Download file
        try:
            response = requests.get(file_url)
            response.raise_for_status()
            file_content = BytesIO(response.content)
        except Exception as e:
            logger.error(f"Error downloading file for OCR: {str(e)}")
            ocr_record.status = "failed"
            ocr_record.error_message = f"Error downloading file: {str(e)}"
            ocr_record.completed_at = timezone.now()
            ocr_record.save()
            return {"status": "error", "message": f"Error downloading file: {str(e)}"}
        
        # Process OCR
        try:
            image = Image.open(file_content)
            text = pytesseract.image_to_string(image)
            
            # Update OCR record
            ocr_record.text_content = text
            ocr_record.status = "completed"
            ocr_record.completed_at = timezone.now()
            ocr_record.save()
            
            logger.info(f"OCR processing completed for document ID: {ocr_id}")
            return {"status": "success", "ocr_id": ocr_id, "text_length": len(text)}
            
        except Exception as e:
            logger.error(f"Error processing OCR: {str(e)}")
            ocr_record.status = "failed"
            ocr_record.error_message = f"Error processing OCR: {str(e)}"
            ocr_record.completed_at = timezone.now()
            ocr_record.save()
            return {"status": "error", "message": f"Error processing OCR: {str(e)}"}
            
    except Exception as e:
        logger.error(f"Unexpected error in OCR task: {str(e)}")
        return {"status": "error", "message": f"Unexpected error: {str(e)}"}

================
File: tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: urls.py
================
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views


router = DefaultRouter()
router.register(r'files', views.FileViewSet, basename='file')
router.register(r'categories', views.CategoryViewSet, basename='category')
router.register(r'cards', views.CardDetailsViewSet, basename='card')
router.register(r'subscriptions', views.AppSubscriptionViewSet, basename='subscription')

urlpatterns = [
    path('upload/', views.file_upload_view, name='file_upload'),
    path('files/', views.file_list_view, name='file_list'),
    path('start_transcription/<str:file_name>/', views.start_transcription, name='start_transcription'),
    path('get_transcription_result/<str:job_name>/', views.get_transcription_result, name='get_transcription_result'),
    path('text_analysis/<str:job_name>/', views.text_analysis, name='text_analysis'),
    # path('index_document/<str:doc_id>/', views.index_existing_document, name='index_existing_document'),
    # path('search_documents/<str:job_name>/', views.search_documents, name='search_documents'),
    path('ocr/process/<int:file_id>/', views.process_document_ocr, name='process_ocr'),
    path('ocr/result/<str:job_id>/', views.get_ocr_result, name='get_ocr_result'),
    path('api/', include(router.urls)),
    path('cards/', views.card_list_view, name='card_list'),
    path('subscriptions/', views.subscription_list_view, name='subscription_list'),
    path('delete/<int:file_id>/', views.delete_file, name='delete_file'),
    path('api/files/', views.file_list_view, name='api_file_list'),
    path('api/files/<int:file_id>/', views.file_detail_view, name='api_file_detail'),
    path('api/upload/', views.file_upload_view, name='api_file_upload'),
    path('api/expired-items/', views.expired_items_view, name='api_expired_items'),
    path('api/mobile/files/', views.mobile_file_list, name='mobile_file_list'),
    path('api/mobile/files/<int:file_id>/', views.mobile_file_detail, name='mobile_file_detail'),
    path('api/mobile/files/<int:file_id>/move/', views.move_file, name='move_file'),
    path('api/mobile/files/<int:file_id>/share/', views.share_file, name='share_file'),
    path('api/mobile/files/<int:file_id>/lock/', views.lock_file, name='lock_file'),
    path('api/mobile/files/<int:file_id>/unlock/', views.unlock_file, name='unlock_file'),
    path('api/mobile/files/<int:file_id>/rename/', views.rename_file, name='rename_file'),
    path('api/mobile/files/<int:file_id>/ocr/', views.mobile_ocr_status, name='mobile_ocr_status'),
    path('api/mobile/files/<int:file_id>/process-ocr/', views.mobile_process_ocr, name='mobile_process_ocr'),
    path('api/mobile/ocr-preferences/', views.ocr_preferences, name='ocr_preferences'),
    path('api/mobile/upload/', views.mobile_file_upload, name='mobile_file_upload'),
    path('api/documents/create-pair/', views.create_document_pair, name='create_document_pair'),
    path('api/documents/<int:file_id>/break-pair/', views.break_document_pair, name='break_document_pair'),
    path('api/documents/paired/', views.get_paired_documents, name='get_paired_documents'),
    path('api/ocr/check-pending/', views.check_pending_ocr_jobs, name='check_pending_ocr'),
    path('api/ocr/status/<int:file_id>/', views.get_file_ocr_status, name='get_file_ocr_status'),

]

================
File: utils.py
================
# import docx
# import io
# from django.http import JsonResponse 
# from django.shortcuts import get_object_or_404
# from .models import UserFile,OCRResult,FileCategory
# from storage_management.models import UserStorage
# import boto3
# from django.conf import settings

# def extract_text_from_document(file_obj, file_extension):
#     """Extract text from various document formats"""
#     try:
#         if file_extension == 'txt':
#             # For text files
#             content = file_obj.read()
#             try:
#                 # Try UTF-8 first
#                 return content.decode('utf-8')
#             except UnicodeDecodeError:
#                 # Fall back to latin-1 if UTF-8 fails
#                 return content.decode('latin-1')
                
#         elif file_extension == 'docx':
#             # For Word documents
#             doc = docx.Document(io.BytesIO(file_obj.read()))
#             return '\n'.join([paragraph.text for paragraph in doc.paragraphs])
            
#         return None
        
#     except Exception as e:
#         raise Exception(f"Error extracting text from {file_extension} file: {str(e)}")

# # # Update process_document_ocr view
# # def process_document_ocr(request, file_id):
# #     try:
# #         user_file = get_object_or_404(UserFile, id=file_id)
# #         file_name = user_file.file.name
# #         file_extension = file_name.split('.')[-1].lower()
        
# #         # Set default category as Personal
# #         default_category, _ = FileCategory.objects.get_or_create(
# #             name='Personal',
# #             defaults={'is_default': True}
# #         )
# #         user_file.category = default_category
# #         user_file.save()

# #         def categorize_file(text_content):
# #             """Helper function to categorize the file based on extracted text."""
# #             categorization_service = FileCategorizationService()
# #             analysis = categorization_service.analyze_file_content(text_content)
            
# #             if analysis['confidence'] >= 40:
# #                 category, _ = FileCategory.objects.get_or_create(
# #                     name=analysis['category'],
# #                     defaults={'is_default': True}
# #                 )
# #                 user_file.category = category
# #                 user_file.save()
# #                 return category.name, analysis
# #             return 'Personal', analysis

# #         # Handle text-based files (txt, docx, md)
# #         if file_extension in ['txt', 'docx', 'md']:
# #             try:
# #                 file_content = extract_text_from_document(user_file.file, file_extension)
# #                 if file_content:
# #                     category_name, analysis = categorize_file(file_content)
# #                     ocr_result, created = OCRResult.objects.update_or_create(
# #                         file=user_file,
# #                         defaults={
# #                             'status': 'completed',
# #                             'text_content': file_content
# #                         }
# #                     )
# #                     return JsonResponse({
# #                         'status': 'completed',
# #                         'text': file_content.split('\n'),
# #                         'category': category_name,
# #                         'analysis': analysis
# #                     })
# #             except Exception as e:
# #                 return JsonResponse({
# #                     'error': f'Error processing file: {str(e)}',
# #                     'category': 'Personal'
# #                 }, status=500)

# #         # Initialize AWS Textract client
# #         textract_client = boto3.client(
# #             'textract',
# #             aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
# #             aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
# #             region_name=settings.AWS_S3_REGION_NAME
# #         )

# #         document_path = user_file.file.name

# #         try:
# #             # Handle images (jpg, jpeg, png)
# #             if file_extension in ['jpg', 'jpeg', 'png']:
# #                 response = textract_client.detect_document_text(
# #                     Document={
# #                         'S3Object': {
# #                             'Bucket': settings.AWS_STORAGE_BUCKET_NAME,
# #                             'Name': document_path
# #                         }
# #                     }
# #                 )
                
# #                 extracted_text = [item['Text'] for item in response['Blocks'] if item['BlockType'] == 'LINE']
# #                 text_content = '\n'.join(extracted_text)
                
# #                 # Categorize content
# #                 category_name, analysis = categorize_file(text_content)
                
# #                 ocr_result, created = OCRResult.objects.update_or_create(
# #                     file=user_file,
# #                     defaults={
# #                         'status': 'completed',
# #                         'text_content': text_content
# #                     }
# #                 )
                
# #                 return JsonResponse({
# #                     'status': 'completed',
# #                     'text': extracted_text,
# #                     'category': category_name,
# #                     'analysis': analysis
# #                 })

# #             # Handle PDFs
# #             elif file_extension == 'pdf':
# #                 response = textract_client.start_document_analysis(
# #                     DocumentLocation={
# #                         'S3Object': {
# #                             'Bucket': settings.AWS_STORAGE_BUCKET_NAME,
# #                             'Name': document_path
# #                         }
# #                     },
# #                     FeatureTypes=['TABLES', 'FORMS']
# #                 )
                
# #                 job_id = response['JobId']
                
# #                 # Create or update OCR result
# #                 ocr_result, created = OCRResult.objects.update_or_create(
# #                     file=user_file,
# #                     defaults={
# #                         'status': 'processing',
# #                         'job_id': job_id
# #                     }
# #                 )
                
# #                 return JsonResponse({
# #                     'status': 'processing',
# #                     'job_id': job_id
# #                 })
            
# #             else:
# #                 return JsonResponse({
# #                     'error': 'Unsupported file type',
# #                     'category': 'Personal'
# #                 }, status=400)

# #         except textract_client.exceptions.InvalidS3ObjectException:
# #             return JsonResponse({
# #                 'error': 'File not accessible in S3',
# #                 'category': 'Personal'
# #             }, status=400)
# #         except textract_client.exceptions.UnsupportedDocumentException:
# #             return JsonResponse({
# #                 'error': 'Document format not supported',
# #                 'category': 'Personal'
# #             }, status=400)
# #         except Exception as e:
# #             return JsonResponse({
# #                 'error': str(e),
# #                 'category': 'Personal'
# #             }, status=500)

# #     except Exception as e:
# #         return JsonResponse({
# #             'error': str(e),
# #             'category': 'Personal'
# #         }, status=500)


# class FileCategorizationService:
#     CATEGORY_KEYWORDS = {
#         'Notes': [
#             'note', 'notes', 'memo', 'reminder', 'todo', 'task',
#             'meeting notes', 'summary', 'key points', 'highlights',
#             'agenda', 'minutes', 'checklist', 'observations',
#             'review notes', 'lecture notes'
#         ],
#         'Personal': [
#             'personal', 'family', 'home', 'private', 'diary',
#             'vacation', 'travel', 'birthday', 'anniversary',
#             'journal', 'memories', 'personal goals', 'bucket list',
#             'life events', 'hobbies', 'recipes', 'fitness'
#         ],
#         'Banking': [
#             'bank', 'account', 'transaction', 'credit', 'debit',
#             'statement', 'balance', 'loan', 'emi', 'payment',
#             'transfer', 'deposit', 'withdrawal', 'ifsc', 'bank branch',
#             'interest', 'savings', 'cheque', 'passbook', 'net banking',
#             'upi', 'credit card', 'debit card', 'banking'
#         ],
#         'Professional': [
#             'resume', 'cv', 'work', 'job', 'office', 'business',
#             'client', 'project', 'proposal', 'contract', 'agreement',
#             'meeting', 'professional', 'corporate', 'company',
#             'employment', 'salary', 'appraisal', 'performance review',
#             'offer letter', 'resignation', 'portfolio', 'work experience',
#             'interview', 'background'
#         ],
#         'Education': [
#             'school', 'college', 'university', 'course', 'study',
#             'assignment', 'exam', 'grade', 'result', 'certificate',
#             'degree', 'diploma', 'student', 'professor', 'lecture',
#             'syllabus', 'curriculum', 'academic', 'education',
#             'semester', 'research', 'thesis', 'dissertation',
#             'classroom', 'training', 'workshop', 'seminar','syllabus'
#         ],
#         'Weblinks': [
#             'http', 'https', 'www', '.com', '.org', '.edu',
#             'website', 'url', 'link', 'web', 'site', 'portal',
#             'online', 'internet', 'webpage', 'browser', 'bookmark',
#             'domain', 'web address', 'hyperlink', 'html'
#         ],
#         'Medical': [
#             'hospital', 'doctor', 'prescription', 'medical', 'health',
#             'medicine', 'patient', 'clinic', 'report', 'test',
#             'diagnosis', 'treatment', 'pharmacy', 'appointment',
#             'healthcare', 'insurance', 'pathology', 'symptoms',
#             'medication', 'consultation', 'laboratory', 'dental',
#             'x-ray', 'vaccination', 'immunization'
#         ],
#         'Visiting_Cards': [
#             'tel:', 'phone:', 'email:', '@', 'contact', 'address:',
#             'mobile', 'website:', 'designation', 'company name',
#             'business card', 'visiting card', 'contact details',
#             'phone number', 'fax:', 'cell:', 'office address',
#             'linkedin', 'social media', 'professional profile'
#         ],
#         'Investments': [
#             'invest', 'stock', 'share', 'mutual fund', 'dividend',
#             'portfolio', 'returns', 'investment', 'equity', 'bond',
#             'demat', 'trading', 'nse', 'bse', 'market', 'profit',
#             'securities', 'holdings', 'financial', 'assets',
#             'commodities', 'forex', 'cryptocurrency', 'bitcoin',
#             'gold', 'real estate', 'property', 'capital gains'
#         ]
#     }

#     def get_category(self, text_content, default_category='Personal'):
#         """
#         Analyze text content and return the most likely category using weighted scoring
#         """
#         if not text_content:
#             return default_category

#         text_lower = text_content.lower()
        
#         # Score categories with weights
#         category_scores = {}
        
#         for category, keywords in self.CATEGORY_KEYWORDS.items():
#             score = 0
#             for keyword in keywords:
#                 # Count occurrences
#                 count = text_lower.count(keyword.lower())
                
#                 # Add weight based on keyword specificity
#                 if len(keyword) > 8:  # Longer keywords are more specific
#                     score += count * 2
#                 else:
#                     score += count
                
#                 # Add extra weight for exact matches
#                 if f" {keyword.lower()} " in f" {text_lower} ":
#                     score += 3
                    
#                 # Add extra weight for keywords in title/filename
#                 if keyword.lower() in text_lower.split('\n')[0].lower():
#                     score += 5

#             if score > 0:
#                 category_scores[category] = score

#         # Calculate confidence scores
#         if category_scores:
#             max_score = max(category_scores.values())
#             if max_score >= 3:  # Minimum threshold for categorization
#                 return max(category_scores.items(), key=lambda x: x[1])[0]
            
#         return default_category

#     def analyze_file_content(self, text_content):
#         """
#         Analyze file content and return detailed categorization info
#         """
#         if not text_content:
#             return {'category': 'Personal', 'confidence': 0, 'matches': []}

#         text_lower = text_content.lower()
#         category_matches = {}
        
#         for category, keywords in self.CATEGORY_KEYWORDS.items():
#             matches = []
#             for keyword in keywords:
#                 count = text_lower.count(keyword.lower())
#                 if count > 0:
#                     matches.append({
#                         'keyword': keyword,
#                         'count': count,
#                         'exact_match': f" {keyword.lower()} " in f" {text_lower} "
#                     })
#             if matches:
#                 category_matches[category] = matches

#         # Get primary category
#         category = self.get_category(text_content)
        
#         # Calculate confidence
#         confidence = 0
#         if category in category_matches:
#             total_matches = sum(match['count'] for match in category_matches[category])
#             exact_matches = sum(1 for match in category_matches[category] if match['exact_match'])
#             confidence = min((total_matches + exact_matches * 2) / 10, 1) * 100

#         return {
#             'category': category,
#             'confidence': confidence,
#             'matches': category_matches
#         }

# def create_default_categories():
#     """Create default categories if they don't exist"""
#     default_categories = [
#         ('Personal', 'Personal documents and information'),
#         ('Banking', 'Banking statements and financial documents'),
#         ('Professional', 'Work-related documents'),
#         ('Education', 'Academic certificates and educational documents'),
#         ('Medical', 'Healthcare-related documents'),
#         ('Visiting Cards', 'Business cards and contact information'),
#         ('Investments', 'Investment certificates and documents'),
#         ('Miscellaneous', 'Uncategorized documents')
#     ]
    
#     for name, description in default_categories:
#         FileCategory.objects.get_or_create(
#             name=name,
#             defaults={
#                 'description': description,
#                 'is_default': True
#             }
#         )


import docx
import io
import boto3
from django.conf import settings
from django.shortcuts import get_object_or_404
from .models import UserFile, OCRResult, FileCategory
import requests

def download_file_from_s3(s3_key):
    """Download file content from S3"""
    try:
        s3_client = boto3.client(
            's3',
            aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
            aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
            region_name=settings.AWS_S3_REGION_NAME
        )
        
        response = s3_client.get_object(
            Bucket=settings.AWS_STORAGE_BUCKET_NAME,
            Key=s3_key
        )
        return response['Body'].read()
    except Exception as e:
        print(f"Error downloading file from S3: {str(e)}")
        raise

def extract_text_from_document(s3_key, file_extension):
    """Extract text from various document formats stored in S3"""
    try:
        # Download file content from S3
        file_content = download_file_from_s3(s3_key)
        
        if file_extension == 'txt':
            # For text files
            try:
                return file_content.decode('utf-8')
            except UnicodeDecodeError:
                return file_content.decode('latin-1')
                
        elif file_extension == 'docx':
            # For Word documents
            doc = docx.Document(io.BytesIO(file_content))
            return '\n'.join([paragraph.text for paragraph in doc.paragraphs])
            
        elif file_extension == 'md':
            # For Markdown files
            try:
                return file_content.decode('utf-8')
            except UnicodeDecodeError:
                return file_content.decode('latin-1')
            
        return None
        
    except Exception as e:
        raise Exception(f"Error extracting text from {file_extension} file: {str(e)}")

class FileCategorizationService:
    CATEGORY_KEYWORDS = {
        'Professional': [
            # Core professional terms
            'resume', 'cv', 'curriculum vitae', 'work', 'job', 'office', 'business',
            'cover letter', 'application letter', 'employment', 'career',
            
            # Job application terms
            'dear hiring manager', 'dear sir', 'dear madam', 'application',
            'opportunity', 'candidate', 'hire', 'hiring', 'recruit', 'position',
            'role', 'vacancy', 'opening', 'interview', 'qualified', 'qualifications',
            
            # Work experience terms
            'experience', 'skills', 'achievements', 'responsibilities', 'duties',
            'accomplishments', 'projects', 'managed', 'developed', 'led', 'created',
            'implemented', 'improved', 'increased', 'reduced', 'streamlined',
            
            # Professional relationships
            'client', 'customer', 'colleague', 'team', 'supervisor', 'manager',
            'director', 'executive', 'professional', 'corporate', 'company',
            'organization', 'department', 'division',
            
            # Business terms
            'project', 'proposal', 'contract', 'agreement', 'meeting',
            'presentation', 'report', 'analysis', 'strategy', 'planning',
            'budget', 'revenue', 'profit', 'sales', 'marketing',
            
            # Employment terms
            'salary', 'compensation', 'benefits', 'promotion', 'appraisal',
            'performance review', 'offer letter', 'resignation', 'termination',
            'notice period', 'reference', 'recommendation',
            
            # Closing terms
            'sincerely', 'regards', 'best regards', 'yours faithfully',
            'thank you for your consideration', 'look forward to hearing',
            'available for interview', 'discuss further'
        ],
        'Education': [
            'school', 'college', 'university', 'course', 'study', 'education',
            'assignment', 'exam', 'grade', 'result', 'certificate', 'transcript',
            'degree', 'diploma', 'bachelor', 'master', 'phd', 'doctorate',
            'student', 'professor', 'teacher', 'instructor', 'lecture', 'class',
            'syllabus', 'curriculum', 'academic', 'semester', 'term', 'year',
            'research', 'thesis', 'dissertation', 'paper', 'publication',
            'classroom', 'training', 'workshop', 'seminar', 'conference',
            'scholarship', 'financial aid', 'tuition', 'enrollment', 'admission',
            'gpa', 'honors', 'dean list', 'graduation', 'commencement'
        ],
        'Banking': [
            'bank', 'banking', 'account', 'checking', 'savings', 'transaction',
            'credit', 'debit', 'statement', 'balance', 'loan', 'mortgage',
            'emi', 'payment', 'transfer', 'deposit', 'withdrawal', 'atm',
            'ifsc', 'routing number', 'bank branch', 'interest', 'apr',
            'cheque', 'check', 'passbook', 'net banking', 'online banking',
            'upi', 'credit card', 'debit card', 'mastercard', 'visa',
            'overdraft', 'minimum balance', 'service charge', 'fee',
            'investment', 'mutual fund', 'fixed deposit', 'recurring deposit',
            'swift code', 'wire transfer', 'direct deposit', 'ach'
        ],
        'Medical': [
            'hospital', 'clinic', 'doctor', 'physician', 'nurse', 'medical',
            'health', 'healthcare', 'medicine', 'medication', 'prescription',
            'patient', 'diagnosis', 'treatment', 'therapy', 'surgery',
            'appointment', 'consultation', 'examination', 'checkup',
            'insurance', 'copay', 'deductible', 'claim', 'coverage',
            'pathology', 'laboratory', 'test', 'results', 'blood work',
            'x-ray', 'mri', 'ct scan', 'ultrasound', 'biopsy',
            'symptoms', 'condition', 'disease', 'illness', 'injury',
            'vaccination', 'immunization', 'shot', 'vaccine',
            'dental', 'dentist', 'orthodontist', 'optometrist', 'cardiologist'
        ],
        'Personal': [
            'personal', 'family', 'home', 'private', 'diary', 'journal',
            'vacation', 'holiday', 'travel', 'trip', 'birthday', 'anniversary',
            'wedding', 'celebration', 'party', 'event', 'memories',
            'personal goals', 'bucket list', 'life events', 'milestone',
            'hobbies', 'interests', 'recreation', 'leisure', 'entertainment',
            'recipes', 'cooking', 'fitness', 'exercise', 'workout', 'gym',
            'relationships', 'friendship', 'dating', 'marriage', 'children',
            'pets', 'house', 'apartment', 'moving', 'utilities', 'bills'
        ],
        'Legal': [
            'legal', 'law', 'attorney', 'lawyer', 'court', 'judge', 'lawsuit',
            'contract', 'agreement', 'terms', 'conditions', 'clause',
            'settlement', 'litigation', 'trial', 'hearing', 'deposition',
            'affidavit', 'notary', 'witness', 'testimony', 'evidence',
            'plaintiff', 'defendant', 'jurisdiction', 'statute', 'regulation',
            'compliance', 'violation', 'penalty', 'fine', 'damages',
            'intellectual property', 'copyright', 'trademark', 'patent',
            'will', 'estate', 'trust', 'probate', 'inheritance'
        ],
        'Notes': [
            'note', 'notes', 'memo', 'reminder', 'todo', 'task', 'list',
            'meeting notes', 'summary', 'key points', 'highlights', 'takeaways',
            'agenda', 'minutes', 'checklist', 'observations', 'thoughts',
            'review notes', 'lecture notes', 'study notes', 'research notes',
            'ideas', 'brainstorm', 'draft', 'outline', 'plan', 'strategy'
        ],
        'Investments': [
            'invest', 'investment', 'portfolio', 'stock', 'stocks', 'share',
            'shares', 'equity', 'bond', 'bonds', 'mutual fund', 'etf',
            'dividend', 'returns', 'yield', 'capital gains', 'profit', 'loss',
            'demat', 'trading', 'broker', 'brokerage', 'commission',
            'nse', 'bse', 'nasdaq', 'nyse', 'market', 'bull', 'bear',
            'securities', 'holdings', 'asset', 'assets', 'allocation',
            'diversification', 'risk', 'volatility', 'performance',
            'commodities', 'gold', 'silver', 'oil', 'forex', 'currency',
            'cryptocurrency', 'bitcoin', 'ethereum', 'blockchain',
            'real estate', 'property', 'reit', 'retirement', '401k', 'ira'
        ]
    }

    def get_category(self, text_content, default_category='Miscellaneous'):
        """Analyze text content and return the most likely category"""
        if not text_content or len(text_content.strip()) < 10:
            return default_category

        text_lower = text_content.lower()
        category_scores = {}
        
        for category, keywords in self.CATEGORY_KEYWORDS.items():
            score = 0
            keyword_matches = 0
            
            for keyword in keywords:
                # Count occurrences
                count = text_lower.count(keyword.lower())
                if count > 0:
                    keyword_matches += 1
                    
                    # Add weight based on keyword specificity and length
                    if len(keyword) > 10:  # Very specific keywords
                        score += count * 4
                    elif len(keyword) > 6:  # Moderately specific
                        score += count * 3
                    else:
                        score += count * 2
                    
                    # Bonus for exact word matches
                    if f" {keyword.lower()} " in f" {text_lower} ":
                        score += 5
                        
                    # Extra bonus for keywords in first part of document
                    first_part = text_lower[:500]
                    if keyword.lower() in first_part:
                        score += 3

            # Apply multiplier based on number of different keywords matched
            if keyword_matches > 0:
                diversity_multiplier = min(1 + (keyword_matches * 0.1), 2.0)
                category_scores[category] = score * diversity_multiplier

        if category_scores:
            max_score = max(category_scores.values())
            # Lower threshold for better categorization
            if max_score >= 5:  # Reduced from 10
                return max(category_scores.items(), key=lambda x: x[1])[0]
            
        return default_category

    def analyze_file_content(self, text_content):
        """Analyze file content and return detailed categorization info"""
        if not text_content or len(text_content.strip()) < 10:
            return {'category': 'Miscellaneous', 'confidence': 0, 'matches': []}

        text_lower = text_content.lower()
        category_matches = {}
        category_scores = {}
        
        for category, keywords in self.CATEGORY_KEYWORDS.items():
            matches = []
            total_score = 0
            
            for keyword in keywords:
                count = text_lower.count(keyword.lower())
                if count > 0:
                    keyword_score = count * (len(keyword) // 3 + 1)  # Length-based scoring
                    if f" {keyword.lower()} " in f" {text_lower} ":
                        keyword_score += 5  # Exact match bonus
                    
                    total_score += keyword_score
                    matches.append({
                        'keyword': keyword,
                        'count': count,
                        'exact_match': f" {keyword.lower()} " in f" {text_lower} ",
                        'score': keyword_score
                    })
            
            if matches:
                category_matches[category] = matches
                category_scores[category] = total_score

        # Get primary category
        category = self.get_category(text_content)
        
        # Calculate confidence
        confidence = 0
        if category in category_scores and category_scores:
            max_score = max(category_scores.values())
            total_score = sum(category_scores.values())
            
            if total_score > 0:
                # Base confidence on relative score
                relative_score = category_scores[category] / max_score
                confidence = min(relative_score * 100, 100)

        return {
            'category': category,
            'confidence': confidence,
            'matches': category_matches,
            'scores': category_scores
        }
    
def create_default_categories():
    """Create default categories if they don't exist"""
    default_categories = [
        ('Personal', 'Personal documents and information'),
        ('Banking', 'Banking statements and financial documents'),
        ('Professional', 'Work-related documents'),
        ('Education', 'Academic certificates and educational documents'),
        ('Medical', 'Healthcare-related documents'),
        ('Visiting Cards', 'Business cards and contact information'),
        ('Investments', 'Investment certificates and documents'),
        ('Miscellaneous', 'Uncategorized documents')
    ]
    
    for name, description in default_categories:
        FileCategory.objects.get_or_create(
            name=name,
            defaults={
                'description': description,
                'is_default': True
            }
        )

================
File: views.py
================
from django.shortcuts import render
from django.http import JsonResponse
from .models import UserFile,OCRResult,FileCategory,CardDetails,ExpiryDetails
from .serializers import UserFileSerializer, FileCategorySerializer, OCRResultSerializer,FileUploadSerializer, FileSearchSerializer, AppSubscription, CardDetailsSerializer, AppSubscriptionSerializer
from rest_framework.decorators import api_view, permission_classes
from .forms import FileUploadForm
import os, boto3, time, re
from django.core.files.storage import default_storage
from django.conf import settings
from voice_retrieval import settings
from django.http import JsonResponse
from django.shortcuts import get_object_or_404
from django.contrib.auth.decorators import login_required
from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.views.decorators.http import require_http_methods
from rest_framework.response import Response
from django.db.models import Q
from .services import ExpiryManagementService
from datetime import date
from storage_management.utils import S3StorageManager
from django.db import transaction, models

textract_client = boto3.client(
    'textract',
    aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
    aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
    region_name=settings.AWS_S3_REGION_NAME
)


# def file_upload_view(request):
#     if request.method == 'POST':
#         form = FileUploadForm(request.POST, request.FILES)
#         if form.is_valid():
#             user_file = form.save()
#             return JsonResponse({
#                 "message": "File uploaded successfully",
#                 "file_url": user_file.file.url
#             })
#     else:
#         form = FileUploadForm()
#     return render(request, 'file_management/upload.html', {'form': form})

# @login_required
# def file_upload_view(request):
#     if request.method == 'POST':
#         form = FileUploadForm(request.POST, request.FILES)
#         if form.is_valid():
#             try:
#                 file_obj = request.FILES['file']
#                 storage_manager = S3StorageManager(request.user)
                
#                 # Check storage limit
#                 if not storage_manager.check_storage_limit(file_obj.size):
#                     return JsonResponse({
#                         'error': 'Storage limit would be exceeded'
#                     }, status=400)
                
#                 # Create file in memory
#                 file_content = file_obj.read()
#                 in_memory_file = io.BytesIO(file_content)
#                 in_memory_file.name = file_obj.name
                
#                 # Upload file to S3
#                 file_key = storage_manager.upload_file(
#                     in_memory_file,
#                     file_obj.name
#                 )
                
#                 # Create UserFile record
#                 user_file = form.save(commit=False)
#                 user_file.user = request.user
#                 user_file.file.name = file_key
#                 user_file.save()
                
#                 # Get updated storage info
#                 storage_info = storage_manager.get_user_storage_info()
                
#                 return JsonResponse({
#                     'message': 'File uploaded successfully',
#                     'file_url': user_file.file.url,
#                     'storage_info': storage_info
#                 })
                
#             except Exception as e:
#                 return JsonResponse({
#                     'error': str(e)
#                 }, status=500)
#     else:
#         form = FileUploadForm()
    
#     return render(request, 'file_management/upload.html', {'form': form})

# def file_list_view(request):
#     # Get all user files
#     files = UserFile.objects.filter(user=request.user)
    
#     # Initialize expiry service
#     expiry_service = ExpiryManagementService()
#     today = date.today()

#     # Get regular category counts
#     category_counts = {}
#     for category in FileCategory.objects.all():
#         if category.name == 'EXPIRED_DOCS':
#             # Count all expired items
#             expired_count = ExpiryDetails.objects.filter(
#                 Q(document__user=request.user) |
#                 Q(card__user=request.user) |
#                 Q(subscription__user=request.user)
#             ).count()
#             category_counts[category.name] = expired_count
#         else:
#             # Count active files in each category
#             count = files.filter(category=category).count()
#             category_counts[category.name] = count

#     # Prepare regular categories
#     categories = [
#         {
#             'name': category.name,
#             'count': category_counts.get(category.name, 0),
#             'type': 'expired' if category.name == 'EXPIRED_DOCS' else 'regular'
#         } for category in FileCategory.objects.all()
#     ]

#     # Get cards with expiry status
#     cards = CardDetails.objects.filter(user=request.user)
#     active_cards = cards.filter(
#         Q(expiry_year__gt=today.year) |
#         (Q(expiry_year=today.year) & Q(expiry_month__gte=today.month))
#     )

#     # Get subscriptions with expiry status
#     subscriptions = AppSubscription.objects.filter(user=request.user)
#     active_subscriptions = subscriptions.filter(
#         Q(end_date__gte=today) |
#         Q(auto_renewal=True)
#     )

#     # Add special categories
#     special_categories = [
#         {
#             'name': 'Cards',
#             'type': 'special',
#             'count': active_cards.count(),
#             'total_count': cards.count(),
#             'expired_count': cards.count() - active_cards.count()
#         },
#         {
#             'name': 'Subscriptions',
#             'type': 'special',
#             'count': active_subscriptions.count(),
#             'total_count': subscriptions.count(),
#             'expired_count': subscriptions.count() - active_subscriptions.count()
#         }
#     ]

#     # Get all expired items for preview
#     expired_items = {
#         'documents': files.filter(category__name='EXPIRED_DOCS'),
#         'cards': cards.exclude(
#             Q(expiry_year__gt=today.year) |
#             (Q(expiry_year=today.year) & Q(expiry_month__gte=today.month))
#         ),
#         'subscriptions': subscriptions.filter(
#             end_date__lt=today,
#             auto_renewal=False
#         )
#     }

#     # Return template with all context
#     return render(request, 'file_management/file_list.html', {
#         'files': files,
#         'categories': categories + special_categories,
#         'expired_items': expired_items,
#         'active_cards': active_cards,
#         'active_subscriptions': active_subscriptions,
#         'cards': cards,
#         'subscriptions': subscriptions,
#         'today': today,
#         'expired_category_exists': FileCategory.objects.filter(name='EXPIRED_DOCS').exists()
#     })
    
@login_required
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def delete_file(request, file_id):
    try:
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)
        
        try:
            # Use S3StorageManager to delete the file
            storage_manager = S3StorageManager(request.user)
            
            # Extract the filename from the s3_key or file.name
            file_key = user_file.s3_key
            if not file_key and user_file.file:
                file_key = user_file.file.name
                
            # If we have a full path, extract just the filename
            if file_key and '/' in file_key:
                file_name = file_key.split('/')[-1]
            else:
                file_name = file_key
                
            if file_name:
                try:
                    # Delete from S3 using the storage manager
                    storage_manager.delete_file(file_name)
                except Exception as s3_error:
                    print(f"S3 deletion error: {str(s3_error)}")
                    # Continue with database deletion even if S3 deletion fails
            
            # Delete the database record
            user_file.delete()
            
            return JsonResponse({
                'status': 'success',
                'message': 'File deleted successfully'
            })
            
        except Exception as e:
            return JsonResponse({
                'status': 'error',
                'message': f'Error deleting file: {str(e)}'
            }, status=500)
            
    except UserFile.DoesNotExist:
        return JsonResponse({
            'status': 'error',
            'message': 'File not found'
        }, status=404)


def cleanup_local_files():
    local_folder = os.path.join(settings.MEDIA_ROOT, 'uploads/')
    if os.path.exists(local_folder):
        for file_name in os.listdir(local_folder):
            file_path = os.path.join(local_folder, file_name)
            default_storage.delete(file_path)  # deletes from local storage


# Initialize Boto3 client for Transcribe
transcribe_client = boto3.client(
    'transcribe',
    aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
    aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
    region_name=settings.AWS_S3_REGION_NAME
)

'''
The feature to download the transcription would be handled at the frontend 
<script>
    async function startTranscription(fileName) {
        const response = await fetch(`/file_management/start_transcription/${fileName}/`);
        const data = await response.json();
        
        if (data.job_name) {
            checkTranscriptionStatus(data.job_name);
        } else {
            alert("Error starting transcription");
        }
    }

    async function checkTranscriptionStatus(jobName) {
        // Poll the server every 2 seconds to check the job status
        setTimeout(async () => {
            const statusResponse = await fetch(`/file_management/get_transcription_result/${jobName}/`);
            const statusData = await statusResponse.json();

            if (statusData.status === "completed") {
                window.location.href = statusData.transcript_url;  // Redirect to download the file
            } else if (statusData.status === "failed") {
                alert("Transcription job failed.");
            } else {
                checkTranscriptionStatus(jobName);  // Check again after 2 seconds
            }
        }, 2000);
    }
</script>

'''


def start_transcription(request, file_name):
    file_url = f"s3://{settings.AWS_STORAGE_BUCKET_NAME}/uploads/{file_name}"
    job_name = f"transcription-job-{int(time.time())}"


    try:
        # Start the transcription job
        response = transcribe_client.start_transcription_job(
            TranscriptionJobName=job_name,
            Media={'MediaFileUri': file_url},
            MediaFormat='mp3',  #to match your audio format
            LanguageCode='en-US',  #using a different language
            OutputBucketName=settings.AWS_STORAGE_BUCKET_NAME,
            OutputKey=f"transcriptions/{job_name}.json"
        )

        return JsonResponse({"message": "Transcription job started", "job_name": job_name})

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)


def get_transcription_result(request, job_name):
    try:
        # Get the job status
        response = transcribe_client.get_transcription_job(TranscriptionJobName=job_name)
        status = response['TranscriptionJob']['TranscriptionJobStatus']

        if status == 'COMPLETED':
            transcript_url = response['TranscriptionJob']['Transcript']['TranscriptFileUri']
            return JsonResponse({"status": "completed", "transcript_url": transcript_url})
        elif status == 'FAILED':
            return JsonResponse({"status": "failed", "message": response['TranscriptionJob']['FailureReason']})

        return JsonResponse({"status": status})

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)


comprehend_client = boto3.client(
    'comprehend',
    aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
    aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
    region_name=settings.AWS_S3_REGION_NAME
)

def text_analysis(request, job_name):
    try:
        # Retrieve the transcription result
        transcription_response = transcribe_client.get_transcription_job(TranscriptionJobName=job_name)
        if transcription_response['TranscriptionJob']['TranscriptionJobStatus'] != 'COMPLETED':
            return JsonResponse({"error": "Transcription job not completed yet."}, status=400)

        transcript_url = transcription_response['TranscriptionJob']['Transcript']['TranscriptFileUri']

        # Download and read the transcript file
        import requests
        transcript_data = requests.get(transcript_url).json()
        text = transcript_data['results']['transcripts'][0]['transcript']

        # Analyze text with Amazon Comprehend
        response = comprehend_client.detect_entities(Text=text, LanguageCode='en')
        entities = response.get('Entities', [])
        
        key_phrases_response = comprehend_client.detect_key_phrases(Text=text, LanguageCode='en')
        key_phrases = key_phrases_response.get('KeyPhrases', [])

        return JsonResponse({
            "transcript": text,
            "entities": entities,
            "key_phrases": key_phrases
        })

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)
    

# from opensearchpy import OpenSearch

# Connect to OpenSearch
# opensearch_client = OpenSearch(
#     hosts=[{'host': settings.OPENSEARCH_HOST, 'port': settings.OPENSEARCH_PORT}],
#     http_auth=(settings.AWS_ACCESS_KEY_ID, settings.AWS_SECRET_ACCESS_KEY),
#     use_ssl=True,
#     verify_certs=True
# )


# def index_document(doc_id, content, index_name='documents'):
#     # Define the document to index
#     document = {
#         "content": content
#     }
#     # Index the document
#     response = opensearch_client.index(index=index_name, id=doc_id, body=document)
#     return response


# def index_existing_document(request, doc_id):
#     # For demonstration, here is placeholder text as content
#     content = "This is the content of the document with ID " + doc_id
#     response = index_document(doc_id=doc_id, content=content)
#     return JsonResponse(response)


# def search_documents(request, job_name):
#     try:
#         # Call the text analysis endpoint to get entities and key phrases
#         response = text_analysis(request, job_name)
#         if 'error' in response:
#             return JsonResponse(response, status=500)

#         # Construct the search query
#         query_terms = [phrase['Text'] for phrase in response['key_phrases']]
#         search_query = {
#             "query": {
#                 "multi_match": {
#                     "query": " ".join(query_terms),
#                     "fields": ["content"]
#                 }
#             }
#         }

#         # Perform the search
#         search_response = opensearch_client.search(index='documents', body=search_query)
#         hits = search_response['hits']['hits']

#         return JsonResponse({
#             "status": "success",
#             "results": hits
#         })

#     except Exception as e:
#         return JsonResponse({"error": str(e)}, status=500)

import pandas as pd
import io
from .utils import extract_text_from_document
from .utils import FileCategorizationService


# def process_document_ocr(request, file_id):
#     try:
#         user_file = get_object_or_404(UserFile, id=file_id)
#         file_name = user_file.file.name
#         file_extension = file_name.split('.')[-1].lower()
        
#         # Set default category as Personal
#         default_category, _ = FileCategory.objects.get_or_create(
#             name='Personal',
#             defaults={'is_default': True}
#         )
#         user_file.category = default_category
#         user_file.save()

#         def categorize_file(text_content):
#             """Helper function to categorize the file based on extracted text."""
#             categorization_service = FileCategorizationService()
#             analysis = categorization_service.analyze_file_content(text_content)
            
#             if analysis['confidence'] >= 40:
#                 category, _ = FileCategory.objects.get_or_create(
#                     name=analysis['category'],
#                     defaults={'is_default': True}
#                 )
#                 user_file.category = category
#                 user_file.save()
#                 return category.name, analysis
#             return 'Personal', analysis

#         # Handle text-based files (txt, docx, md)
#         if file_extension in ['txt', 'docx', 'md']:
#             try:
#                 file_content = extract_text_from_document(user_file.file, file_extension)
#                 if file_content:
#                     category_name, analysis = categorize_file(file_content)
#                     ocr_result, created = OCRResult.objects.update_or_create(
#                         file=user_file,
#                         defaults={
#                             'status': 'completed',
#                             'text_content': file_content
#                         }
#                     )
#                     return JsonResponse({
#                         'status': 'completed',
#                         'text': file_content.split('\n'),
#                         'category': category_name,
#                         'analysis': analysis
#                     })
#             except Exception as e:
#                 return JsonResponse({
#                     'error': f'Error processing file: {str(e)}',
#                     'category': 'Personal'
#                 }, status=500)

#         # Initialize AWS Textract client
#         textract_client = boto3.client(
#             'textract',
#             aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
#             aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
#             region_name=settings.AWS_S3_REGION_NAME
#         )

#         document_path = user_file.file.name

#         try:
#             # Handle images (jpg, jpeg, png)
#             if file_extension in ['jpg', 'jpeg', 'png']:
#                 response = textract_client.detect_document_text(
#                     Document={
#                         'S3Object': {
#                             'Bucket': settings.AWS_STORAGE_BUCKET_NAME,
#                             'Name': document_path
#                         }
#                     }
#                 )
                
#                 extracted_text = [item['Text'] for item in response['Blocks'] if item['BlockType'] == 'LINE']
#                 text_content = '\n'.join(extracted_text)
                
#                 # Categorize content
#                 category_name, analysis = categorize_file(text_content)
                
#                 ocr_result, created = OCRResult.objects.update_or_create(
#                     file=user_file,
#                     defaults={
#                         'status': 'completed',
#                         'text_content': text_content
#                     }
#                 )
                
#                 return JsonResponse({
#                     'status': 'completed',
#                     'text': extracted_text,
#                     'category': category_name,
#                     'analysis': analysis
#                 })

#             # Handle PDFs
#             elif file_extension == 'pdf':
#                 response = textract_client.start_document_analysis(
#                     DocumentLocation={
#                         'S3Object': {
#                             'Bucket': settings.AWS_STORAGE_BUCKET_NAME,
#                             'Name': document_path
#                         }
#                     },
#                     FeatureTypes=['TABLES', 'FORMS']
#                 )
                
#                 job_id = response['JobId']
                
#                 # Create or update OCR result
#                 ocr_result, created = OCRResult.objects.update_or_create(
#                     file=user_file,
#                     defaults={
#                         'status': 'processing',
#                         'job_id': job_id
#                     }
#                 )
                
#                 return JsonResponse({
#                     'status': 'processing',
#                     'job_id': job_id
#                 })
            
#             else:
#                 return JsonResponse({
#                     'error': 'Unsupported file type',
#                     'category': 'Personal'
#                 }, status=400)

#         except textract_client.exceptions.InvalidS3ObjectException:
#             return JsonResponse({
#                 'error': 'File not accessible in S3',
#                 'category': 'Personal'
#             }, status=400)
#         except textract_client.exceptions.UnsupportedDocumentException:
#             return JsonResponse({
#                 'error': 'Document format not supported',
#                 'category': 'Personal'
#             }, status=400)
#         except Exception as e:
#             return JsonResponse({
#                 'error': str(e),
#                 'category': 'Personal'
#             }, status=500)

#     except Exception as e:
#         return JsonResponse({
#             'error': str(e),
#             'category': 'Personal'
#         }, status=500)
    
def get_ocr_result(request, job_id):
    try:
        # Fetch the OCR result and associated file
        ocr_result = get_object_or_404(OCRResult, job_id=job_id)
        user_file = ocr_result.file

        # Get the original category name
        original_category = user_file.category
        original_category_name = original_category.name if original_category else 'Miscellaneous'
        
        # Check if this is a user-selected category (not Miscellaneous)
        is_user_selected = original_category_name != 'Miscellaneous'

        # Return the result if already completed
        if ocr_result.status == 'completed' and ocr_result.text_content:
            category_name = user_file.category.name if user_file.category else 'Miscellaneous'
            return JsonResponse({
                'status': 'completed',
                'text': ocr_result.text_content.split('\n'),
                'category': category_name,
                'file_id': user_file.id,
                'original_category': original_category_name
            })

        # Set up AWS Textract client
        textract_client = boto3.client(
            'textract',
            aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
            aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
            region_name=settings.AWS_S3_REGION_NAME
        )

        # Get OCR processing status and response
        try:
            response = textract_client.get_document_analysis(JobId=job_id)

            if response['JobStatus'] == 'SUCCEEDED':
                # Extract text from response
                extracted_text = [
                    block['Text'] for block in response['Blocks']
                    if block['BlockType'] == 'LINE'
                ]
                text_content = '\n'.join(extracted_text)

                # Update OCR result in the database
                ocr_result.text_content = text_content
                ocr_result.status = 'completed'
                ocr_result.save()

                # Categorize the content only if not user-selected
                categorization_service = FileCategorizationService()
                analysis = categorization_service.analyze_file_content(text_content)
                
                # Only change category if analysis is confident and it's not a user-selected category
                category_changed = False
                if analysis['confidence'] >= 40 and not is_user_selected:
                    category, _ = FileCategory.objects.get_or_create(
                        name=analysis['category'],
                        defaults={'is_default': True}
                    )
                    
                    # If category changed, update and notify user
                    if original_category and category.id != original_category.id:
                        user_file.category = category
                        user_file.save()
                        category_changed = True
                        
                        # Send notification to user
                        try:
                            from django.core.mail import send_mail
                            
                            send_mail(
                                'File Category Changed',
                                f'Your file "{user_file.original_filename}" has been moved from "{original_category_name}" to "{category.name}" category based on its content.',
                                settings.DEFAULT_FROM_EMAIL,
                                [user_file.user.email],
                                fail_silently=True,
                            )
                        except Exception as notification_error:
                            print(f"Failed to send notification: {str(notification_error)}")
                
                category_name = user_file.category.name if user_file.category else 'Miscellaneous'

                return JsonResponse({
                    'status': 'completed',
                    'text': extracted_text,
                    'category': category_name,
                    'category_changed': category_changed,
                    'original_category': original_category_name,
                    'file_id': user_file.id
                })

            elif response['JobStatus'] == 'FAILED':
                ocr_result.status = 'failed'
                ocr_result.save()
                return JsonResponse({
                    'status': 'failed',
                    'error': response.get('StatusMessage', 'OCR processing failed'),
                    'category': original_category_name
                }, status=400)

            # Return in-progress status
            return JsonResponse({
                'status': response['JobStatus'],
                'progress': response.get('Progress', 0),
                'category': original_category_name
            })

        except textract_client.exceptions.InvalidJobIdException:
            ocr_result.status = 'failed'
            ocr_result.save()
            return JsonResponse({
                'error': 'Invalid or expired job ID',
                'category': original_category_name
            }, status=400)

    except Exception as e:
        return JsonResponse({   
            'error': str(e),
            'category': 'Miscellaneous'
        }, status=500)
    
from storage_management.utils import S3StorageManager
from storage_management.models import UserStorage
from django.http import JsonResponse
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils.decorators import method_decorator

def file_upload_view(request):
    if request.method == 'POST':
        form = FileUploadForm(request.POST, request.FILES)
        if form.is_valid():
            try:
                file_obj = request.FILES['file']
                storage_manager = S3StorageManager(request.user)
                
                # Check storage limit
                if not storage_manager.check_storage_limit(file_obj.size):
                    return JsonResponse({
                        'error': 'Storage limit would be exceeded'
                    }, status=400)
                
                # Create file in memory
                file_content = file_obj.read()
                in_memory_file = io.BytesIO(file_content)
                in_memory_file.name = file_obj.name
                
                # Upload file to S3
                file_key = storage_manager.upload_file(
                    in_memory_file,
                    file_obj.name
                )
                
                # Create UserFile record
                user_file = form.save(commit=False)
                user_file.user = request.user
                user_file.file.name = file_key
                user_file.save()
                
                # Get updated storage info
                storage_info = storage_manager.get_user_storage_info()
                
                return JsonResponse({
                    'message': 'File uploaded successfully',
                    'file_url': user_file.file.url,
                    'storage_info': storage_info
                })
                
            except Exception as e:
                return JsonResponse({
                    'error': str(e)
                }, status=500)
    else:
        form = FileUploadForm()
    
    return render(request, 'file_management/upload.html', {'form': form})

# Signal to update storage limit when subscription changes
@receiver(post_save, sender='payments.Subscription')
def update_storage_limit(sender, instance, created, **kwargs):
    if instance.status == 'active':
        storage, created = UserStorage.objects.get_or_create(user=instance.user)
        
        # Update storage limit based on plan
        if instance.plan == 'basic':
            storage.storage_limit = 5 * 1024 * 1024 * 1024  # 5GB
        elif instance.plan == 'premium':
            storage.storage_limit = 20 * 1024 * 1024 * 1024  # 20GB
        elif instance.plan == 'enterprise':
            storage.storage_limit = 50 * 1024 * 1024 * 1024  # 50GB
        
        storage.save()


# Custom category creation view
@login_required
def create_custom_category(request):
    if request.method == 'POST':
        category_name = request.POST.get('name')
        description = request.POST.get('description', '')
        
        try:
            category = FileCategory.objects.create(
                name=category_name,
                description=description,
                is_default=False,
                created_by=request.user
            )
            
            return JsonResponse({
                'status': 'success',
                'category': {
                    'id': category.id,
                    'name': category.name,
                    'description': category.description
                }
            })
            
        except Exception as e:
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=400)
    
    return JsonResponse({'status': 'error', 'message': 'Invalid request'}, status=400)

from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator

class CardDetailsViewSet(viewsets.ModelViewSet):

    @method_decorator(csrf_exempt)
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)
    serializer_class = CardDetailsSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return CardDetails.objects.filter(user=self.request.user)

    def get_serializer_context(self):
        context = super().get_serializer_context()
        context['request'] = self.request
        return context

    @action(detail=False, methods=['post'])
    def extract_from_document(self, request):
        file_id = request.data.get('file_id')
        if not file_id:
            return Response({'error': 'File ID is required'}, 
                        status=status.HTTP_400_BAD_REQUEST)

        try:
            user_file = UserFile.objects.get(id=file_id, user=request.user)
            ocr_result = OCRResult.objects.get(file=user_file)
            
            text_content = ocr_result.text_content
            
            # Card number pattern (16 digits, may be space/dash separated)
            card_pattern = r'\b(?:\d[ -]*?){13,16}\b'
            # Expiry date pattern (MM/YY or MM/YYYY)
            expiry_pattern = r'\b(0[1-9]|1[0-2])/([0-9]{2}|2[0-9]{3})\b'
            # Cardholder name pattern (usually in caps)
            name_pattern = r'\b[A-Z][A-Z\s]{2,}\b'

            # Find patterns in text
            card_numbers = re.findall(card_pattern, text_content)
            expiry_dates = re.findall(expiry_pattern, text_content)
            possible_names = re.findall(name_pattern, text_content)

            cards_found = []
            for card_number in card_numbers:
                # Clean the card number
                clean_number = ''.join(filter(str.isdigit, card_number))
                
                if len(clean_number) in [15, 16]:  # Valid card length
                    card = {
                        'card_number': clean_number,
                        'card_type': 'credit',  # Default to credit
                        'bank_name': 'Unknown Bank',  # Default bank name
                    }
                    
                    # Add expiry date if found
                    if expiry_dates:
                        month, year = expiry_dates[0]
                        card['expiry_month'] = month
                        card['expiry_year'] = '20' + year if len(year) == 2 else year
                    
                    # Add cardholder name if found
                    if possible_names:
                        card['card_holder'] = possible_names[0]
                    
                    cards_found.append(card)

            return Response({
                'cards_found': cards_found,
                'message': f'Found {len(cards_found)} potential card(s)'
            })

        except UserFile.DoesNotExist:
            return Response({'error': 'File not found'}, 
                        status=status.HTTP_404_NOT_FOUND)
        except OCRResult.DoesNotExist:
            return Response({'error': 'OCR result not found'}, 
                        status=status.HTTP_404_NOT_FOUND)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class AppSubscriptionViewSet(viewsets.ModelViewSet):
    @method_decorator(csrf_exempt)
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)
    serializer_class = AppSubscriptionSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return AppSubscription.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

    @action(detail=False, methods=['post'])
    def extract_from_document(self, request):
        file_id = request.data.get('file_id')
        if not file_id:
            return Response({'error': 'File ID is required'}, 
                        status=status.HTTP_400_BAD_REQUEST)

        try:
            user_file = UserFile.objects.get(id=file_id, user=request.user)
            ocr_result = OCRResult.objects.get(file=user_file)
            
            text_content = ocr_result.text_content.lower()
            
            # Common subscription services and their patterns
            services = {
                'netflix': {
                    'pattern': r'netflix.*?(\$|₹)(\d+\.?\d*)',
                    'types': ['Basic', 'Standard', 'Premium']
                },
                'amazon prime': {
                    'pattern': r'prime.*?(\$|₹)(\d+\.?\d*)',
                    'types': ['Monthly', 'Annual']
                },
                'spotify': {
                    'pattern': r'spotify.*?(\$|₹)(\d+\.?\d*)',
                    'types': ['Individual', 'Family', 'Student']
                },
                'disney+': {
                    'pattern': r'disney\+.*?(\$|₹)(\d+\.?\d*)',
                    'types': ['Monthly', 'Annual']
                }
            }

            subs_found = []
            for service, info in services.items():
                matches = re.findall(info['pattern'], text_content)
                if matches:
                    # Find dates in the text nearby
                    date_pattern = r'\d{1,2}[-/]\d{1,2}[-/]\d{2,4}'
                    dates = re.findall(date_pattern, text_content)
                    
                    for match in matches:
                        sub = {
                            'app_name': service.title(),
                            'amount': float(match[1]),
                            'subscription_type': 'Monthly',  # Default
                            'auto_renewal': True,
                            'status': 'active'
                        }
                        
                        # Add dates if found
                        if len(dates) >= 2:
                            from datetime import datetime
                            try:
                                sub['start_date'] = datetime.strptime(dates[0], '%d/%m/%Y').date()
                                sub['end_date'] = datetime.strptime(dates[1], '%d/%m/%Y').date()
                            except ValueError:
                                # Default dates if parsing fails
                                from datetime import date, timedelta
                                sub['start_date'] = date.today()
                                sub['end_date'] = date.today() + timedelta(days=30)
                        else:
                            # Default dates
                            from datetime import date, timedelta
                            sub['start_date'] = date.today()
                            sub['end_date'] = date.today() + timedelta(days=30)
                        
                        subs_found.append(sub)

            return Response({
                'subscriptions_found': subs_found,
                'message': f'Found {len(subs_found)} potential subscription(s)'
            })

        except UserFile.DoesNotExist:
            return Response({'error': 'File not found'}, 
                          status=status.HTTP_404_NOT_FOUND)
        except OCRResult.DoesNotExist:
            return Response({'error': 'OCR result not found'}, 
                          status=status.HTTP_404_NOT_FOUND)

    def destroy(self, request, *args, **kwargs):
        subscription = self.get_object()
        subscription.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

# from django.http import HttpResponseForbidden
# @login_required
# def card_list_view(request):
#     if request.user.is_authenticated:
#         cards = CardDetails.objects.filter(user=request.user)
#         files = UserFile.objects.filter(user=request.user)
#         return render(request, 'file_management/cards/card_list.html', {
#             'cards': cards,
#             'files': files
#         })
#     else:
#         return HttpResponseForbidden("You are not authorized to view this page.")


# def subscription_list_view(request):
#     subscriptions = AppSubscription.objects.filter(user=request.user)
#     cards = CardDetails.objects.filter(user=request.user)
#     files = UserFile.objects.filter(user=request.user)
#     return render(request, 'file_management/subscriptions/subscription_list.html', {
#         'subscriptions': subscriptions,
#         'cards': cards,
#         'files': files
#     })

# def expired_items_view(request):
#     service = ExpiryManagementService()
#     expired_items = service.get_expired_items(request.user)
    
#     return render(request, 'file_management/expired_items.html', {
#         'expired_items': expired_items
#     })



class FileViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]
    serializer_class = UserFileSerializer
    
    def get_queryset(self):
        return UserFile.objects.filter(user=self.request.user)

    def create(self, request):
        serializer = FileUploadSerializer(data=request.data)
        if serializer.is_valid():
            file_obj = serializer.validated_data['file']
            
            # Initialize storage manager
            storage_manager = S3StorageManager(request.user)
            
            # Check storage limit
            if not storage_manager.check_storage_limit(file_obj.size):
                return Response({
                    'error': 'Storage limit would be exceeded'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            try:
                # Upload file to S3
                s3_key = storage_manager.upload_file(file_obj, file_obj.name)
                
                # Create UserFile record
                user_file = UserFile.objects.create(
                    user=request.user,
                    file_type=serializer.validated_data['file_type'],
                    file=s3_key,
                    category_id=serializer.validated_data.get('category_id')
                )
                
                return Response(
                    UserFileSerializer(user_file).data,
                    status=status.HTTP_201_CREATED
                )
                
            except Exception as e:
                return Response({
                    'error': str(e)
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
                
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=False, methods=['post'])
    def search(self, request):
        serializer = FileSearchSerializer(data=request.data)
        if serializer.is_valid():
            queryset = self.get_queryset()
            
            # Apply filters
            if query := serializer.validated_data.get('query'):
                queryset = queryset.filter(
                    Q(original_filename__icontains=query) |
                    Q(category__name__icontains=query)
                )
            
            if file_type := serializer.validated_data.get('file_type'):
                queryset = queryset.filter(file_type=file_type)
                
            if category := serializer.validated_data.get('category'):
                queryset = queryset.filter(category_id=category)
                
            if date_from := serializer.validated_data.get('date_from'):
                queryset = queryset.filter(upload_date__gte=date_from)
                
            if date_to := serializer.validated_data.get('date_to'):
                queryset = queryset.filter(upload_date__lte=date_to)
            
            return Response(
                UserFileSerializer(queryset, many=True).data
            )
            
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['get'])
    def ocr_status(self, request, pk=None):
        user_file = self.get_object()
        try:
            ocr_result = OCRResult.objects.get(file=user_file)
            return Response(OCRResultSerializer(ocr_result).data)
        except OCRResult.DoesNotExist:
            return Response({
                'status': 'not_started'
            })

    @action(detail=True, methods=['post'])
    def start_ocr(self, request, pk=None):
        user_file = self.get_object()
        # Reuse existing OCR processing logic
        response = process_document_ocr(request, user_file.id)
        return Response(response.json())

class CategoryViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]
    serializer_class = FileCategorySerializer
    
    def get_queryset(self):
        # Return both default categories and user's custom categories
        return FileCategory.objects.filter(
            Q(is_default=True) | Q(created_by=self.request.user)
        )

    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)

    @action(detail=True, methods=['get'])
    def files(self, request, pk=None):
        category = self.get_object()
        files = UserFile.objects.filter(
            user=request.user,
            category=category
        )
        return Response(
            UserFileSerializer(files, many=True).data
        )

from django.views.decorators.csrf import csrf_exempt
from django.core.mail import send_mail

def process_document_ocr_async(request, file_id):
    """Process document OCR asynchronously"""
    try:
        # Create a new request object for the async task since the original may not be available
        print(f"[OCR Async] Starting OCR for file {file_id}")
        
        # Call OCR logic directly with user ID
        user_id = request.user.id
        result = process_document_ocr_logic(user_id, file_id)
        print(f"[OCR Async] OCR completed with result: {result}")
        return result
    except Exception as e:
        print(f"[OCR Async] Error in async OCR processing: {str(e)}")
        import traceback
        traceback.print_exc()
        
        # On error, try to clear the pending flag directly
        try:
            file = UserFile.objects.get(id=file_id)
            if file.pending_auto_categorization:
                file.pending_auto_categorization = False
                # Ensure the file has a category
                if not file.category:
                    misc_category, _ = FileCategory.objects.get_or_create(
                        name='Miscellaneous',
                        defaults={'is_default': True}
                    )
                    file.category = misc_category
                file.save(update_fields=['pending_auto_categorization', 'category'])
                print(f"[OCR Async] Cleared pending flag for file {file_id} after error")
        except Exception as inner_e:
            print(f"[OCR Async] Failed to clear pending flag: {inner_e}")
        
        return {"status": "error", "error": str(e), "file_id": file_id}


# ============================================
# CENTRALIZED OCR & CATEGORIZATION LOGIC
# ============================================
def process_document_ocr_logic(user_id, file_id):
    """
    Handles OCR extraction, text analysis, categorization, and notifications.
    Designed to be run asynchronously after file upload or Textract completion.
    """
    text_content = None
    ocr_status = 'failed'
    ocr_result = None
    misc_category = None
    
    try:
        # Use user_id to fetch user if necessary, ensure file belongs to user
        user_file = UserFile.objects.select_related('category', 'user').get(id=file_id, user_id=user_id)
        user = user_file.user # Get user from the file object
        original_category = user_file.category
        original_category_name = original_category.name if original_category else "Miscellaneous" # Use Miscellaneous if None

        # Get or create Miscellaneous category for fallback
        misc_category, _ = FileCategory.objects.get_or_create(
            name='Miscellaneous',
            defaults={'is_default': True, 'description': 'Uncategorized files'}
        )

        file_name = user_file.file.name # This is the S3 key
        file_extension = user_file.original_filename.split('.')[-1].lower() if user_file.original_filename else ''

        print(f"[OCR Logic] Starting for file: {user_file.id}, original category: {original_category_name}, ext: {file_extension}")

        ocr_status = 'pending'
        job_id = None # For async Textract jobs

        # --- Step 1: Extract Text ---
        # Check if OCR result already exists and has content (e.g., from async job)
        existing_ocr = OCRResult.objects.filter(file=user_file).first()
        if existing_ocr and existing_ocr.status == 'completed' and existing_ocr.text_content:
            print(f"[OCR Logic] Using existing OCR text for file {user_file.id}")
            text_content = existing_ocr.text_content
            ocr_status = 'completed'
        elif file_extension in ['txt', 'docx', 'md']:
             print(f"[OCR Logic] Extracting text directly for file {user_file.id}")
             try:
                 # Assuming user_file.file is FieldFile pointing to S3
                 storage = default_storage # Or your specific S3 storage backend
                 with storage.open(user_file.file.name, 'rb') as file_obj:
                    text_content = extract_text_from_document(file_obj, file_extension)
                 ocr_status = 'completed' if text_content is not None else 'failed'
             except Exception as extraction_error:
                 print(f"[OCR Logic] Error extracting text directly: {extraction_error}")
                 ocr_status = 'failed'
                 text_content = f"Error during text extraction: {extraction_error}"
        elif file_extension in ['jpg', 'jpeg', 'png']:
            print(f"[OCR Logic] Processing image with Textract synchronously for file {user_file.id}")
            try:
                textract_client = boto3.client(
                    'textract',
                    aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
                    aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
                    region_name=settings.AWS_S3_REGION_NAME
                )
                response = textract_client.detect_document_text(
                    Document={'S3Object': {'Bucket': settings.AWS_STORAGE_BUCKET_NAME, 'Name': user_file.file.name}}
                )
                extracted_lines = [item['Text'] for item in response['Blocks'] if item['BlockType'] == 'LINE']
                text_content = '\n'.join(extracted_lines)
                ocr_status = 'completed'
            except Exception as textract_error:
                print(f"[OCR Logic] Textract sync error: {textract_error}")
                ocr_status = 'failed'
                text_content = f"Error during synchronous Textract processing: {textract_error}"
        elif file_extension == 'pdf':
            print(f"[OCR Logic] Starting async Textract job for PDF file {user_file.id}")
            try:
                textract_client = boto3.client(
                    'textract',
                    aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
                    aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
                    region_name=settings.AWS_S3_REGION_NAME
                )
                # Check if a job is already running for this file
                if existing_ocr and existing_ocr.status == 'processing' and existing_ocr.job_id:
                     print(f"[OCR Logic] Async job {existing_ocr.job_id} already in progress.")
                     # For admin panel, we want to wait and get results rather than return early
                     # Try to check the job status
                     try:
                         response = textract_client.get_document_analysis(JobId=existing_ocr.job_id)
                         job_status = response['JobStatus']
                         if job_status == 'SUCCEEDED':
                             print(f"[OCR Logic] Previous job {existing_ocr.job_id} succeeded, retrieving results")
                             blocks = response.get('Blocks', [])
                             extracted_lines = [block['Text'] for block in blocks if block.get('BlockType') == 'LINE']
                             if extracted_lines:
                                 text_content = '\n'.join(extracted_lines)
                                 ocr_status = 'completed'
                                 # Update the OCR result
                                 existing_ocr.status = 'completed'
                                 existing_ocr.text_content = text_content
                                 existing_ocr.save()
                         else:
                             print(f"[OCR Logic] Job {existing_ocr.job_id} status: {job_status}, not ready yet")
                             return {
                                 'status': 'processing',
                                 'job_id': existing_ocr.job_id,
                                 'message': f"Textract job is still {job_status.lower()}"
                             }
                     except Exception as job_check_error:
                         print(f"[OCR Logic] Error checking job {existing_ocr.job_id}: {job_check_error}")
                         # Continue with starting a new job
                
                # Start a new job if needed
                if ocr_status != 'completed':  # If previous steps didn't complete OCR
                    response = textract_client.start_document_analysis(
                        DocumentLocation={'S3Object': {'Bucket': settings.AWS_STORAGE_BUCKET_NAME, 'Name': user_file.file.name}},
                        FeatureTypes=['TABLES', 'FORMS'] # Adjust as needed
                    )
                    job_id = response['JobId']
                    ocr_status = 'processing'
                    # Save job_id immediately
                    ocr_result, _ = OCRResult.objects.update_or_create(
                        file=user_file,
                        defaults={'status': ocr_status, 'job_id': job_id, 'text_content': None}
                    )
                    print(f"[OCR Logic] Async job {job_id} started.")
                    
                    # For PDF files in admin, we need to inform that OCR is still in progress
                    # but we need to clear the pending flag to avoid endless attempts
                    if user_file.pending_auto_categorization:
                        print(f"[OCR Logic] Clearing pending flag for file {user_file.id} since PDF OCR is in progress")
                        user_file.pending_auto_categorization = False
                        user_file.save(update_fields=['pending_auto_categorization'])
                    
                    return {
                        'status': 'processing', 
                        'job_id': job_id,
                        'message': "PDF document OCR is processing in the background. Check the file details later."
                    }
            except Exception as textract_error:
                print(f"[OCR Logic] Textract async start error: {textract_error}")
                import traceback
                traceback.print_exc()
                ocr_status = 'failed'
                text_content = f"Error starting asynchronous Textract job: {textract_error}"
        else:
            print(f"[OCR Logic] File type '{file_extension}' not supported for OCR.")
            ocr_status = 'not_applicable' # Or 'unsupported'
            
            # Even for unsupported files, clear the pending flag
            if user_file.pending_auto_categorization:
                user_file.pending_auto_categorization = False
                user_file.save(update_fields=['pending_auto_categorization'])

        # --- Step 2: Update OCRResult Model ---
        ocr_defaults = {'status': ocr_status}
        if text_content is not None:
             ocr_defaults['text_content'] = text_content
        if job_id: # Should not happen here anymore for async, but safe check
             ocr_defaults['job_id'] = job_id

        ocr_result, created = OCRResult.objects.update_or_create(
            file=user_file,
            defaults=ocr_defaults
        )
        print(f"[OCR Logic] OCRResult updated/created for file {user_file.id} with status: {ocr_status}")

        # --- Step 3: Categorize if applicable ---
        category_changed = False
        final_category = original_category
        new_category_name = original_category_name # Initialize with original

        # Only attempt categorization if OCR completed and text was extracted
        if ocr_status == 'completed' and text_content:
            # Check if this file needs auto-categorization (either pending_auto_categorization is True OR it's in Miscellaneous)
            # Auto-categorize if pending flag is set OR if category is Miscellaneous
            should_auto_categorize = user_file.pending_auto_categorization or (original_category and original_category.id == misc_category.id)
            
            if should_auto_categorize:
                print(f"[OCR Logic] Attempting auto-categorization for file {user_file.id}")
                categorization_service = FileCategorizationService()
                analysis = categorization_service.analyze_file_content(text_content)
                print(f"[OCR Logic] Category analysis: {analysis['category']} with confidence {analysis['confidence']}%")

                if analysis['confidence'] >= 40: # Confidence threshold
                    suggested_category_name = analysis['category']
                    # Check if suggested category is different from the original one
                    if suggested_category_name != original_category_name:
                        new_category, _ = FileCategory.objects.get_or_create(
                            name=suggested_category_name,
                            defaults={'is_default': True} # Assuming auto-categories are default type
                        )
                        user_file.category = new_category
                        final_category = new_category
                        new_category_name = new_category.name
                        category_changed = True
                        
                        # Turn off the pending flag, now that we've categorized it
                        if user_file.pending_auto_categorization:
                            user_file.pending_auto_categorization = False
                        
                        # Save the category change
                        user_file.save(update_fields=['category', 'pending_auto_categorization'])
                        print(f"[OCR Logic] Category changed for file {user_file.id} from '{original_category_name}' to '{new_category_name}'")
                    else:
                        print(f"[OCR Logic] Suggested category '{suggested_category_name}' matches original '{original_category_name}'. No change.")
                        # Turn off the pending flag even if we didn't change the category
                        if user_file.pending_auto_categorization:
                            user_file.pending_auto_categorization = False
                            user_file.save(update_fields=['pending_auto_categorization'])
                else:
                    print(f"[OCR Logic] Analysis confidence too low ({analysis['confidence']}%). Keeping original category.")
                    # Turn off the pending flag even if confidence is too low
                    if user_file.pending_auto_categorization:
                        user_file.pending_auto_categorization = False
                        user_file.save(update_fields=['pending_auto_categorization'])
            else:
                print(f"[OCR Logic] Auto-categorization skipped for file {user_file.id} - user-selected category")
                # Make sure pending flag is cleared
                if user_file.pending_auto_categorization:
                    user_file.pending_auto_categorization = False
                    user_file.save(update_fields=['pending_auto_categorization'])
        else:
            # If OCR failed or had no text, clear the pending flag and keep in Miscellaneous
            if user_file.pending_auto_categorization:
                print(f"[OCR Logic] OCR status is '{ocr_status}' - clearing pending flag and keeping in Miscellaneous")
                user_file.pending_auto_categorization = False
                user_file.save(update_fields=['pending_auto_categorization'])

        # --- Return result information ---
        return {
            'status': ocr_status,
            'original_category': original_category_name,
            'final_category': new_category_name,
            'category_changed': category_changed,
            'ocr_id': ocr_result.id if ocr_result else None,
            'text_length': len(text_content) if text_content else 0
        }
        
    except Exception as e:
        print(f"[OCR Logic] Error processing file {file_id}: {str(e)}")
        import traceback
        traceback.print_exc()
        
        # Attempt to clear the pending flag even if the main process fails
        try:
            if 'user_file' in locals() and user_file.pending_auto_categorization:
                # If we have a reference to the user_file, clear its pending flag
                user_file.pending_auto_categorization = False
                if misc_category:
                    user_file.category = misc_category
                user_file.save(update_fields=['pending_auto_categorization', 'category'])
                print(f"[OCR Logic] Cleared pending flag for file {file_id} after error")
            else:
                # If we don't have a user_file reference, try to get it directly
                try:
                    direct_user_file = UserFile.objects.get(id=file_id)
                    if direct_user_file.pending_auto_categorization:
                        direct_user_file.pending_auto_categorization = False
                        # Create Miscellaneous category if needed
                        misc_cat, _ = FileCategory.objects.get_or_create(
                            name='Miscellaneous',
                            defaults={'is_default': True}
                        )
                        direct_user_file.category = misc_cat
                        direct_user_file.save(update_fields=['pending_auto_categorization', 'category'])
                        print(f"[OCR Logic] Cleared pending flag for file {file_id} via direct DB query after error")
                except Exception as inner_e:
                    print(f"[OCR Logic] Could not clear pending flag via direct DB query: {inner_e}")
        except Exception as flag_e:
            print(f"[OCR Logic] Failed to clear pending flag: {flag_e}")
        
        return {
            'status': 'error',
            'error': str(e),
            'file_id': file_id
        }


#view functions to REST API views
@csrf_exempt
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def file_upload_view(request):
    """Fixed file upload with proper OCR triggering"""
    if request.method == 'POST':
        try:
            file_obj = request.FILES.get('file')
            file_type = request.data.get('file_type')
            
            if not file_obj or not file_type:
                return Response({
                    'success': False,
                    'error': 'File and file type are required'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            category_id = request.data.get('category_id') or request.data.get('category')
            
            # Initialize storage manager
            storage_manager = S3StorageManager(request.user)
            
            # Check storage limit
            if not storage_manager.check_storage_limit(file_obj.size):
                return Response({
                    'success': False,
                    'error': 'Storage limit would be exceeded'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # Upload file to S3
            file_key = storage_manager.upload_file(file_obj, file_obj.name)
            
            # Determine category
            category = None
            should_auto_categorize = True
            
            if category_id:
                try:
                    category = FileCategory.objects.get(id=category_id)
                    should_auto_categorize = False
                except FileCategory.DoesNotExist:
                    pass
            
            if not category:
                misc_category, _ = FileCategory.objects.get_or_create(
                    name='Miscellaneous',
                    defaults={'is_default': True, 'description': 'Uncategorized files'}
                )
                category = misc_category
            
            # Create UserFile record
            user_file = UserFile.objects.create(
                user=request.user,
                file_type=file_type,
                file=file_key,
                s3_key=file_key,  # Ensure s3_key is set
                original_filename=file_obj.name,
                file_size=file_obj.size,
                category=category,
                pending_auto_categorization=should_auto_categorize
            )
            
            # Get updated storage info
            storage_info = storage_manager.get_user_storage_info()
            
            # Start OCR processing for document and image files
            ocr_result = {'status': 'not_applicable'}
            if file_type in ['document', 'image']:
                try:
                    from .services import OCRService
                    ocr_service = OCRService()
                    ocr_result = ocr_service.process_file(user_file)
                    print(f"[Upload] OCR result: {ocr_result}")
                except Exception as ocr_error:
                    print(f"[Upload] OCR error: {str(ocr_error)}")
                    ocr_result = {'status': 'error', 'error': str(ocr_error)}
            
            return Response({
                'success': True,
                'message': 'File uploaded successfully',
                'file': UserFileSerializer(user_file).data,
                'storage_info': storage_info,
                'ocr_result': ocr_result
            }, status=status.HTTP_201_CREATED)
                
        except Exception as e:
            return Response({
                'success': False,
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    # GET method for form data
    return Response({
        'file_types': dict(UserFile.FILE_TYPES),
        'categories': FileCategorySerializer(FileCategory.objects.all(), many=True).data
    })

@csrf_exempt
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def file_list_view(request):
    # Get query parameters for filtering
    category = request.query_params.get('category')
    file_type = request.query_params.get('file_type')
    search = request.query_params.get('search')
    
    # Filter files
    files = UserFile.objects.filter(user=request.user)
    
    if category and category != 'all':
        files = files.filter(category__name=category)
    
    if file_type:
        files = files.filter(file_type=file_type)
    
    if search:
        files = files.filter(
            Q(original_filename__icontains=search) |
            Q(category__name__icontains=search)
        )
    
    # Get categories with counts for filters
    categories = []
    for category in FileCategory.objects.all():
        count = UserFile.objects.filter(user=request.user, category=category).count()
        categories.append({
            'id': category.id,
            'name': category.name,
            'count': count,
            'type': 'expired' if category.name == 'EXPIRED_DOCS' else 'regular'
        })
    
    # Special categories counts (cards, subscriptions)
    today = date.today()
    cards = CardDetails.objects.filter(user=request.user)
    active_cards = cards.filter(
        Q(expiry_year__gt=today.year) |
        (Q(expiry_year=today.year) & Q(expiry_month__gte=today.month))
    )
    
    subscriptions = AppSubscription.objects.filter(user=request.user)
    active_subscriptions = subscriptions.filter(
        Q(end_date__gte=today) |
        Q(auto_renewal=True)
    )
    
    special_categories = [
        {
            'name': 'Cards',
            'type': 'special',
            'count': active_cards.count(),
            'total_count': cards.count(),
            'expired_count': cards.count() - active_cards.count()
        },
        {
            'name': 'Subscriptions',
            'type': 'special',
            'count': active_subscriptions.count(),
            'total_count': subscriptions.count(),
            'expired_count': subscriptions.count() - active_subscriptions.count()
        }
    ]
    
    # Get expired items
    expired_items = {
        'documents': UserFileSerializer(files.filter(category__name='EXPIRED_DOCS'), many=True).data,
        'cards': CardDetailsSerializer(cards.exclude(
            Q(expiry_year__gt=today.year) |
            (Q(expiry_year=today.year) & Q(expiry_month__gte=today.month))
        ), many=True).data,
        'subscriptions': AppSubscriptionSerializer(subscriptions.filter(
            end_date__lt=today,
            auto_renewal=False
        ), many=True).data
    }
    
    return Response({
        'files': UserFileSerializer(files, many=True).data,
        'categories': categories + special_categories,
        'expired_items': expired_items,
        'active_cards': CardDetailsSerializer(active_cards, many=True).data,
        'active_subscriptions': AppSubscriptionSerializer(active_subscriptions, many=True).data
    })

@csrf_exempt
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def card_list_view(request):
    cards = CardDetails.objects.filter(user=request.user)
    files = UserFile.objects.filter(user=request.user)
    
    return Response({
        'cards': CardDetailsSerializer(cards, many=True).data,
        'files': UserFileSerializer(files, many=True).data
    })

@csrf_exempt
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def subscription_list_view(request):
    subscriptions = AppSubscription.objects.filter(user=request.user)
    cards = CardDetails.objects.filter(user=request.user)
    files = UserFile.objects.filter(user=request.user)
    
    return Response({
        'subscriptions': AppSubscriptionSerializer(subscriptions, many=True).data,
        'cards': CardDetailsSerializer(cards, many=True).data,
        'files': UserFileSerializer(files, many=True).data
    })

@csrf_exempt
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def expired_items_view(request):
    service = ExpiryManagementService()
    expired_items = service.get_expired_items(request.user)
    
    # Organize expired items by type
    result = {
        'documents': [],
        'cards': [],
        'subscriptions': []
    }
    
    for item in expired_items:
        if item.document:
            result['documents'].append({
                'id': item.document.id,
                'name': item.document.original_filename,
                'category': item.original_category,
                'expiry_date': item.expiry_date
            })
        elif item.card:
            result['cards'].append({
                'id': item.card.id,
                'bank': item.card.bank_name,
                'card_number': f"**** {item.card.card_number[-4:]}",
                'expiry_date': item.expiry_date
            })
        elif item.subscription:
            result['subscriptions'].append({
                'id': item.subscription.id,
                'app_name': item.subscription.app_name,
                'subscription_type': item.subscription.subscription_type,
                'expiry_date': item.expiry_date
            })
    
    return Response(result)

@csrf_exempt
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def file_detail_view(request, file_id):
    try:
        file = get_object_or_404(UserFile, id=file_id, user=request.user)
        ocr_result = None
        
        try:
            if file.file_type == 'document':
                ocr_result = OCRResult.objects.get(file=file)
        except OCRResult.DoesNotExist:
            pass
        
        data = UserFileSerializer(file).data
        if ocr_result and ocr_result.text_content:
            data['ocr_text'] = ocr_result.text_content
            data['ocr_status'] = ocr_result.status
        
        return Response(data)
    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    

from voice_retrieval.utils import mobile_api_view
from .serializers import MobileFileUploadSerializer

@csrf_exempt
@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
@mobile_api_view
def mobile_file_list(request):
    """Mobile-optimized file list endpoint"""
    if request.method == 'GET':
        # Get query parameters for filtering
        category = request.query_params.get('category')
        file_type = request.query_params.get('file_type')
        search = request.query_params.get('search')
        
        # Filter files
        files = UserFile.objects.filter(user=request.user)
        serializer = UserFileSerializer(files, many=True, context={'request': request}) # Add context

        
        if category and category != 'all':
            files = files.filter(category__name=category)
        
        if file_type:
            files = files.filter(file_type=file_type)
        
        if search:
            files = files.filter(
                Q(original_filename__icontains=search) |
                Q(category__name__icontains=search)
            )
            
        # Get categories for filters
        categories = []
        for category in FileCategory.objects.all():
            count = UserFile.objects.filter(user=request.user, category=category).count()
            categories.append({
                'id': category.id,
                'name': category.name,
                'count': count
            })
            
        serializer = UserFileSerializer(files, many=True)
        
        return {
            'files': serializer.data,
            'categories': categories
        }
    
    elif request.method == 'POST':
        # Upload file logic
        try:
            file_obj = request.FILES.get('file')
            file_type = request.data.get('file_type')
            
            if not file_obj or not file_type:
                return Response({
                    'success': False,
                    'error': 'File and file type are required'
                }, status=status.HTTP_400_BAD_REQUEST)
                
            storage_manager = S3StorageManager(request.user)
            
            if not storage_manager.check_storage_limit(file_obj.size):
                return Response({
                    'success': False,
                    'error': 'Storage limit would be exceeded'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # Process file upload
            file_key = storage_manager.upload_file(file_obj, file_obj.name)
            
            user_file = UserFile.objects.create(
                user=request.user,
                file_type=file_type,
                file=file_key,
                original_filename=file_obj.name,
                file_size=file_obj.size
            )
            
            storage_info = storage_manager.get_user_storage_info()
            
            return {
                'file': UserFileSerializer(user_file).data,
                'storage_info': storage_info
            }
                
        except Exception as e:
            return Response({
                'success': False,
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@csrf_exempt
@api_view(['GET', 'DELETE'])
@permission_classes([IsAuthenticated])
@mobile_api_view
def mobile_file_detail(request, file_id):
    """Mobile-optimized file detail endpoint for viewing and deleting files"""
    try:
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)
        
        if request.method == 'GET':
            # Return file details
            serializer = UserFileSerializer(user_file)
            
            # Get OCR result if it exists for documents
            ocr_text = None
            ocr_status = None
            
            if user_file.file_type == 'document':
                try:
                    ocr_result = OCRResult.objects.get(file=user_file)
                    ocr_text = ocr_result.text_content
                    ocr_status = ocr_result.status
                except OCRResult.DoesNotExist:
                    pass
            
            data = serializer.data
            if ocr_text:
                data['ocr_text'] = ocr_text
                data['ocr_status'] = ocr_status
                
            return data
            
        elif request.method == 'DELETE':
            # Delete the file
            try:
                # Get the full S3 key
                file_key = user_file.file.name
                
                # Delete from S3
                storage_manager = S3StorageManager(request.user)
                
                try:
                    # Try to delete from S3
                    s3_client = boto3.client(
                        's3',
                        aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
                        aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
                        region_name=settings.AWS_S3_REGION_NAME
                    )
                    
                    # Delete the object directly
                    s3_client.delete_object(
                        Bucket=settings.AWS_STORAGE_BUCKET_NAME,
                        Key=file_key
                    )
                except Exception as s3_error:
                    print(f"S3 deletion error: {str(s3_error)}")
                    # Continue with database deletion even if S3 deletion fails
                
                # Delete the database record
                user_file.delete()
                
                return {
                    'message': 'File deleted successfully'
                }
                
            except Exception as e:
                return Response({
                    'success': False,
                    'error': f'Error deleting file: {str(e)}'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
                
    except UserFile.DoesNotExist:
        return Response({
            'success': False,
            'error': 'File not found'
        }, status=status.HTTP_404_NOT_FOUND)
    

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def process_document_ocr(request, file_id):
    """Manually trigger OCR processing"""
    try:
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)
        
        # Use OCR service
        from .services import OCRService
        ocr_service = OCRService()
        result = ocr_service.process_file(user_file)
        
        return JsonResponse(result)
        
    except Exception as e:
        return JsonResponse({
            'error': str(e),
            'category': 'Miscellaneous'
        }, status=500)

@csrf_exempt
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def mobile_file_upload(request):
    """Fixed mobile file upload with OCR"""
    serializer = MobileFileUploadSerializer(data=request.data)

    if not serializer.is_valid():
        return Response({'success': False, 'error': serializer.errors}, status=status.HTTP_400_BAD_REQUEST)

    try:
        file_obj = request.FILES.get('file')
        file_type = serializer.validated_data['file_type']
        category_id = serializer.validated_data.get('category_id')

        if not file_obj:
             return Response({'success': False, 'error': 'File not provided'}, status=status.HTTP_400_BAD_REQUEST)

        storage_manager = S3StorageManager(request.user)

        if not storage_manager.check_storage_limit(file_obj.size):
            return Response({'success': False, 'error': 'Storage limit would be exceeded'}, status=status.HTTP_400_BAD_REQUEST)

        # Upload file to S3
        s3_key = storage_manager.upload_file(file_obj, file_obj.name)
        
        # Determine category
        category = None
        should_auto_categorize = True
        
        if category_id:
            try:
                category = FileCategory.objects.get(id=category_id)
                should_auto_categorize = False
            except FileCategory.DoesNotExist:
                pass
        
        if not category:
            misc_category, _ = FileCategory.objects.get_or_create(
                name='Miscellaneous',
                defaults={'is_default': True, 'description': 'Uncategorized files'}
            )
            category = misc_category

        # Create UserFile record
        user_file = UserFile.objects.create(
            user=request.user,
            file_type=file_type,
            file=s3_key,
            s3_key=s3_key,
            original_filename=file_obj.name,
            file_size=file_obj.size,
            category=category,
            pending_auto_categorization=should_auto_categorize
        )
        
        # Get updated storage info
        storage_info = storage_manager.get_user_storage_info()
        
        # Start OCR processing for document and image files
        ocr_result = {'status': 'not_applicable'}
        if file_type in ['document', 'image']:
            try:
                from .services import OCRService
                ocr_service = OCRService()
                ocr_result = ocr_service.process_file(user_file)
                print(f"[Mobile Upload] OCR result: {ocr_result}")
            except Exception as ocr_error:
                print(f"[Mobile Upload] OCR error: {str(ocr_error)}")
                ocr_result = {'status': 'error', 'error': str(ocr_error)}
        
        return Response({
            'success': True,
            'message': 'File uploaded successfully',
            'file': UserFileSerializer(user_file).data,
            'storage_info': storage_info,
            'ocr_result': ocr_result
        }, status=status.HTTP_201_CREATED)
            
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def move_file(request, file_id):
    try:
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)
        category_id = request.data.get('category_id')
        
        if not category_id:
            return Response({
                'success': False,
                'error': 'Category ID is required'
            }, status=status.HTTP_400_BAD_REQUEST)
            
        try:
            category = FileCategory.objects.get(id=category_id)
            
            # Update file category
            user_file.category = category
            user_file.save()
            
            return Response({
                'success': True,
                'message': 'File moved successfully',
                'file': UserFileSerializer(user_file).data
            })
        except FileCategory.DoesNotExist:
            return Response({
                'success': False,
                'error': 'Category not found'
            }, status=status.HTTP_404_NOT_FOUND)
            
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def share_file(request, file_id):
    try:
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)
        
        # Set file as public
        user_file.is_public = True
        user_file.save()
        
        # Generate sharing URL
        storage_manager = S3StorageManager(request.user)
        share_url = storage_manager.get_file_url(user_file.s3_key, expiry=604800)  # 1 week expiry
        
        return Response({
            'success': True,
            'message': 'File shared successfully',
            'share_url': share_url,
            'expires_in': '7 days'
        })
        
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def lock_file(request, file_id):
    try:
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)
        password = request.data.get('password')
        
        if not password:
            return Response({
                'success': False,
                'error': 'Password is required'
            }, status=status.HTTP_400_BAD_REQUEST)
            
        # Hash the password
        from django.contrib.auth.hashers import make_password
        hashed_password = make_password(password)
        
        # Update file
        user_file.locked = True
        user_file.locked_password = hashed_password
        user_file.save()
        
        return Response({
            'success': True,
            'message': 'File locked successfully'
        })
        
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def unlock_file(request, file_id):
    try:
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)
        password = request.data.get('password')
        
        if not password:
            return Response({
                'success': False,
                'error': 'Password is required'
            }, status=status.HTTP_400_BAD_REQUEST)
            
        # Check password
        from django.contrib.auth.hashers import check_password
        if not check_password(password, user_file.locked_password):
            return Response({
                'success': False,
                'error': 'Incorrect password'
            }, status=status.HTTP_400_BAD_REQUEST)
            
        # Unlock file
        user_file.locked = False
        user_file.locked_password = None
        user_file.save()
        
        return Response({
            'success': True,
            'message': 'File unlocked successfully'
        })
        
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def rename_file(request, file_id):
    try:
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)
        new_name = request.data.get('new_name')
        
        if not new_name:
            return Response({
                'success': False,
                'error': 'New name is required'
            }, status=status.HTTP_400_BAD_REQUEST)
            
        # Update file name
        user_file.original_filename = new_name
        user_file.save()
        
        return Response({
            'success': True,
            'message': 'File renamed successfully',
            'file': UserFileSerializer(user_file).data
        })
        
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

from file_management.models import OCRPreference

@csrf_exempt # If needed based on auth setup
@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def ocr_preferences(request):
    ocr_pref, created = OCRPreference.objects.get_or_create(user=request.user)

    if request.method == 'GET':
        return Response({
            'success': True,
            'preference': ocr_pref.preference,
            'display': ocr_pref.get_preference_display()
        })
    elif request.method == 'POST':
        preference = request.data.get('preference')

        if preference not in dict(OCRPreference.OCR_CHOICES).keys(): # Validate against choices
            return Response({
                'success': False,
                'error': 'Invalid preference value.'
            }, status=status.HTTP_400_BAD_REQUEST)

        ocr_pref.preference = preference
        ocr_pref.save()

        return Response({
            'success': True,
            'message': 'OCR preferences updated.',
            'preference': ocr_pref.preference,
            'display': ocr_pref.get_preference_display()
        })
    
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def process_document_ocr_view(request, file_id):
    """
    API endpoint to manually trigger or re-trigger OCR processing for a file.
    """
    try:
        # Ensure the file exists and belongs to the user
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)

        # Check OCR Preference
        ocr_pref, _ = OCRPreference.objects.get_or_create(user=request.user)
        if ocr_pref.preference == 'none':
            return Response({
                'status': 'skipped',
                'message': 'OCR processing is disabled in user preferences.'
             }, status=status.HTTP_400_BAD_REQUEST)
        # If preference is 'selected', this explicit call allows processing.

        print(f"Manual OCR trigger requested for file {file_id}")
        # Set status to pending before triggering async task
        OCRResult.objects.update_or_create(
            file=user_file,
            defaults={'status': 'pending', 'job_id': None, 'text_content': None}
        )

        # Trigger the main logic asynchronously
        user_id = request.user.id
        transaction.on_commit(lambda: process_document_ocr_logic(user_id, file_id))

        return Response({
            'status': 'processing_scheduled',
            'message': 'OCR processing has been scheduled for the file.'
        })

    except UserFile.DoesNotExist:
        return Response({'error': 'File not found'}, status=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        print(f"Error triggering manual OCR for file {file_id}: {str(e)}")
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)



@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_ocr_result(request, job_id):
    """Get OCR result by job ID"""
    try:
        ocr_result = get_object_or_404(OCRResult, job_id=job_id, file__user=request.user)
        user_file = ocr_result.file

        if ocr_result.status == 'completed':
            return JsonResponse({
                'status': 'completed',
                'text': ocr_result.text_content.split('\n') if ocr_result.text_content else [],
                'category': user_file.category.name if user_file.category else 'Miscellaneous',
                'file_id': user_file.id
            })
        elif ocr_result.status == 'failed':
            return JsonResponse({
                'status': 'failed',
                'error': ocr_result.text_content or 'OCR processing failed',
                'category': user_file.category.name if user_file.category else 'Miscellaneous'
            }, status=400)
        elif ocr_result.status == 'processing':
            # Check if job completed
            from .services import OCRService
            ocr_service = OCRService()
            result = ocr_service._complete_pdf_processing(user_file, ocr_result)
            
            if result['status'] == 'completed':
                return JsonResponse({
                    'status': 'completed',
                    'text': ocr_result.text_content.split('\n') if ocr_result.text_content else [],
                    'category': user_file.category.name if user_file.category else 'Miscellaneous',
                    'file_id': user_file.id
                })
            else:
                return JsonResponse({
                    'status': 'processing',
                    'message': 'OCR processing is still in progress'
                })
        else:
            return JsonResponse({
                'status': ocr_result.status,
                'message': f'OCR status: {ocr_result.status}'
            })

    except Exception as e:
        return JsonResponse({
            'error': str(e),
            'category': 'Miscellaneous'
        }, status=500)

def award_coins_for_upload(user, user_file):
    """Award coins for file uploads - utility function for direct API calls"""
    try:
        from coin_wallet.models import CoinWallet, CoinTransaction
        import math
        
        # Calculate coins (1 coin per MB, minimum 1 coin)
        file_size_mb = math.ceil(user_file.file_size / (1024 * 1024))
        if file_size_mb < 1:
            file_size_mb = 1
        
        # Check if coins were already awarded
        if user_file.coins_awarded:
            return {"awarded": False, "reason": "Already awarded", "amount": 0}
        
        # Get or create the user's wallet
        wallet, created = CoinWallet.objects.get_or_create(user=user)
        
        # Check if a transaction already exists
        existing_transaction = CoinTransaction.objects.filter(
            wallet=wallet,
            transaction_type='upload',
            related_file=user_file
        ).exists()
        
        if existing_transaction:
            return {"awarded": False, "reason": "Transaction exists", "amount": 0}
        
        # Award coins
        wallet.add_coins(
            amount=file_size_mb,
            transaction_type='upload',
            source=f'File upload: {user_file.original_filename}'
        )
        
        # Update the transaction with the related file
        transaction = CoinTransaction.objects.filter(
            wallet=wallet,
            transaction_type='upload'
        ).latest('created_at')
        transaction.related_file = user_file
        transaction.save()
        
        # Mark coins as awarded
        user_file.coins_awarded = True
        user_file.save(update_fields=['coins_awarded'])
        
        return {"awarded": True, "amount": file_size_mb}
    except Exception as e:
        print(f"Error awarding coins: {str(e)}")
        return {"awarded": False, "reason": str(e), "amount": 0}
        
# Add after the ocr_preferences function

@csrf_exempt
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def mobile_ocr_status(request, file_id):
    """Mobile-optimized endpoint for getting OCR status and text content."""
    try:
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)
        
        try:
            ocr_result = OCRResult.objects.get(file=user_file)
            
            return Response({
                'success': True,
                'ocr_status': ocr_result.status,
                'ocr_text': ocr_result.text_content if ocr_result.text_content else None,
                'category': user_file.category.name if user_file.category else 'Miscellaneous',
                'file_id': user_file.id
            })
        except OCRResult.DoesNotExist:
            return Response({
                'success': True,
                'ocr_status': 'not_started',
                'message': 'OCR has not been initiated for this file'
            })
    except UserFile.DoesNotExist:
        return Response({
            'success': False,
            'error': 'File not found.'
        }, status=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@csrf_exempt
@api_view(['POST'])
@permission_classes([IsAuthenticated])
@mobile_api_view
def mobile_process_ocr(request, file_id):
    """Mobile-optimized endpoint for triggering OCR processing"""
    try:
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)
        
        # Check if file type is document
        if user_file.file_type != 'document':
            return {
                'success': False,
                'error': 'OCR processing is only available for document files'
            }
            
        # Set status to pending
        OCRResult.objects.update_or_create(
            file=user_file,
            defaults={'status': 'pending', 'job_id': None}
        )
        
        # Trigger OCR processing asynchronously
        user_id = request.user.id
        # Use transaction.on_commit for async processing
        from django.db import transaction
        transaction.on_commit(lambda: process_document_ocr_logic(user_id, file_id))
        
        return {
            'success': True,
            'message': 'OCR processing has been initiated',
            'ocr_status': 'pending'
        }
    except Exception as e:
        return {
            'success': False,
            'error': str(e)
        }


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_document_pair(request):
    """Create a paired document relationship"""
    try:
        front_file_id = request.data.get('front_file_id')
        back_file_id = request.data.get('back_file_id')
        document_type_name = request.data.get('document_type_name', '')
        
        if not front_file_id or not back_file_id:
            return Response({
                'success': False,
                'error': 'Both front_file_id and back_file_id are required'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Get both files and verify ownership
        front_file = get_object_or_404(UserFile, id=front_file_id, user=request.user)
        back_file = get_object_or_404(UserFile, id=back_file_id, user=request.user)
        
        # Update front file
        front_file.document_side = 'front'
        front_file.paired_document = back_file
        front_file.document_type_name = document_type_name
        front_file.save()
        
        # Update back file
        back_file.document_side = 'back'
        back_file.paired_document = front_file
        back_file.document_type_name = document_type_name
        back_file.save()
        
        return Response({
            'success': True,
            'message': 'Document pair created successfully',
            'front_file': UserFileSerializer(front_file).data,
            'back_file': UserFileSerializer(back_file).data
        })
        
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def break_document_pair(request, file_id):
    """Break a document pair relationship"""
    try:
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)
        
        if not user_file.has_pair():
            return Response({
                'success': False,
                'error': 'Document is not paired'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        paired_file = user_file.paired_document
        
        # Reset both files
        user_file.document_side = 'single'
        user_file.paired_document = None
        user_file.save()
        
        if paired_file:
            paired_file.document_side = 'single'
            paired_file.paired_document = None
            paired_file.save()
        
        return Response({
            'success': True,
            'message': 'Document pair broken successfully'
        })
        
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_paired_documents(request):
    """Get all paired documents for the user"""
    try:
        paired_docs = UserFile.objects.filter(
            user=request.user,
            document_side__in=['front', 'back']
        ).select_related('paired_document')
        
        # Group by document type
        grouped_docs = {}
        processed_ids = set()
        
        for doc in paired_docs:
            if doc.id in processed_ids:
                continue
                
            doc_type = doc.document_type_name or 'Unknown Document'
            if doc_type not in grouped_docs:
                grouped_docs[doc_type] = []
            
            pair_data = {
                'document_type': doc_type,
                'front': None,
                'back': None
            }
            
            if doc.document_side == 'front':
                pair_data['front'] = UserFileSerializer(doc).data
                if doc.paired_document:
                    pair_data['back'] = UserFileSerializer(doc.paired_document).data
                    processed_ids.add(doc.paired_document.id)
            elif doc.document_side == 'back':
                pair_data['back'] = UserFileSerializer(doc).data
                if doc.paired_document:
                    pair_data['front'] = UserFileSerializer(doc.paired_document).data
                    processed_ids.add(doc.paired_document.id)
            
            grouped_docs[doc_type].append(pair_data)
            processed_ids.add(doc.id)
        
        return Response({
            'success': True,
            'paired_documents': grouped_docs
        })
        
    except Exception as e:
        return Response({
            'success': False,
            'error': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)



@api_view(['POST'])
@permission_classes([IsAuthenticated])
def check_pending_ocr_jobs(request):
    """Manually check pending OCR jobs"""
    try:
        from .services import OCRService
        ocr_service = OCRService()
        ocr_service.check_pending_jobs()
        return Response({'success': True, 'message': 'Checked pending OCR jobs'})
    except Exception as e:
        return Response({'success': False, 'error': str(e)}, status=500)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_file_ocr_status(request, file_id):
    """Get OCR status for a specific file"""
    try:
        user_file = get_object_or_404(UserFile, id=file_id, user=request.user)
        
        try:
            ocr_result = OCRResult.objects.get(file=user_file)
            return Response({
                'success': True,
                'ocr_status': ocr_result.status,
                'has_text': bool(ocr_result.text_content),
                'text_length': len(ocr_result.text_content) if ocr_result.text_content else 0
            })
        except OCRResult.DoesNotExist:
            return Response({
                'success': True,
                'ocr_status': 'not_started',
                'has_text': False,
                'text_length': 0
            })
    except Exception as e:
        return Response({'success': False, 'error': str(e)}, status=500)
